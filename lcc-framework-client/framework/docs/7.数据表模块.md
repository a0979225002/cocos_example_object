****
[客户端框架文档](./1.客户端框架文档.md)<br/>
****
<br/>

# **数据表模块**

数据表主要是保存的游戏内容的一些常量数据，比如物品表，技能表，职业表，角色表和充值表等。数据表的内容各种各样并且一般比较庞大，游戏策划通过配置表构建游戏的数据模型。数据表模块主要管理数据表的加载使用。由于该框架是基于多分包的模块化游戏内容组织框架，所以数据表配置和资源文件会分散到分包中，甚至某张数据表的内容也可以分散到分包中，分包内只应该包含当前分包的数据表配置和资源文件。

## **模块功能说明**

当前框架数据表配置和资源文件使用JSON格式。`数据表资源文件`是具体数据表的内容文件；`数据表配置文件`是数据表的索引文件。<br/>
数据表模块重要的功能不是数据表的加载使用，而是把游戏数据模型生成数据表格，然后根据数据表格生成开发过程中需要的各种数据表。生成数据表的操作在该框架配套资源构建工具中完成，可以先看原始资源配置和构建文档中关于数据表的部分。<br/>

1. ### 数据表的分类
    数据表根据`结构`可以分为以下两类：<br/>
    * `映射`。表示数据表是一种键值对的映射表，比如Map，唯一健对应指定元素。
    * `排列`。表示数据表是一种数组，比如List，所有元素构成的数组。

    数据表根据`元素类型`可以分为以下三类：<br/>
    * `对象`。表示数据表的元素是复杂的对象，比如 { name:"test", value:1 }。
    * `数组`。表示数据表的元素是数组，比如 [ "test", 1 ]。
    * `数值`。表示数据表的元素是值，比如 "test"、1。

    所以，根据`结构`和`元素类型`，数据表可以分为如下六类：<br/>
    * 映射对象表。`映射` + `对象`的组合，如下实例：<br/>
        ```
            {
                "item1":{
                    "name":"test", 
                    "value":1 
                },
                "item2":{
                    "name":"test2", 
                    "value":2 
                }
            }
        ```
    * 映射数组表。`映射` + `数组`的组合，如下实例：<br/>
        ```
            {
                "item1":[
                    "test",
                    1
                ]
                "item2":[
                    "test2", 
                    2
                ]
            }
        ```
    * 映射表。`映射` + `数值`的组合，如下实例：<br/>
        ```
            {
                "item1":"test",
                "item2":"test2"
            }
        ```
    * 排列对象表。`排列` + `对象`的组合，如下实例：<br/>
        ```
            [
                {
                    "id":"item1",
                    "name":"test", 
                    "value":1 
                },
                {
                    "id":"item2",
                    "name":"test2", 
                    "value":2 
                }
            ]
        ```
    * 排列数组表。`排列` + `数组`的组合，如下实例：<br/>
        ```
            [
                [
                    "item1",
                    "test", 
                    1 
                ],
                [
                    "item2",
                    "test2", 
                    2 
                ]
            ]
        ```
    * 排列表。`排列` + `数值`的组合，如下实例：<br/>
        ```
            [
                "item1",
                "item2"
            ]
        ```

2. ### 关于排列数据表的自动排序功能
    由于该框架是多分包框架，所以可能出现数据表合并的情况。映射数据表因为有唯一健，所以合并很简单。但是，排列数据表合并的时候很难保证元素的顺序，所以就需要排列数据表在加载后排序。<br/>
    通过在全局表中加入`#listSort`配置功能，实现加载后排序功能。如下：<br/>
    `注意`：下面都是完整的数据表资源文件内容，除了数据表内容，还有数据表名称和额外信息。<br/>
    * `排列对象表`自动排序：<br/>
        ```
            {
                "listobject": [
                    {
                        "id":"item1",
                        "name":"test", 
                        "value":1 
                    },
                    {
                        "id":"item2",
                        "name":"test2", 
                        "value":2 
                    }
                ],
                "#listSort": {
                    "listobject": {
                        "key": "id",
                        "sortUp": false
                    }
                }
            }
        ```
        `#listSort`内部，`key`表示排序对象健，`sortUp`是否升序。
    * `排列数组表`自动排序：<br/>
        ```
            {
                "listarray": [
                    [
                        "item1",
                        "test", 
                        1 
                    ],
                    [
                        "item2",
                        "test2", 
                        2 
                    ]
                ],
                "#listSort": {
                    "listarray": {
                        "key": "2",
                        "sortUp": false
                    }
                }
            }
        ```
        `#listSort`内部，`key`表示排序元素序号，`sortUp`是否升序。
    * `排列表`自动排序：<br/>
        ```
            {
                "listvalue": [
                    1,
                    2
                ],
                "#listSort": {
                    "listvalue": {
                        "sortUp": false
                    }
                }
            }
        ```
        `#listSort`内部，根据元素排序，`sortUp`是否升序。
    
## **模块初始化**

数据表模块初始化最好在框架加载后，数据表功能使用前完成。当然也可以用默认参数使用，不初始化数据表模块。<br/>

1. ### 修改数据表加载模式
    `数据表加载模式`可以分为自动加载和手动加载两种模式；<br/>
    * 自动加载模式。这种模式下，数据表会随着分包加载和释放，我们不能控制。
    * 手动加载模式。这种模式下，需要我们手动加载和释放数据表。这种模式相对更灵活，可以选择需要保留的数据表。

    我们可以通过下面的方式修改数据表加载模式：<br/>
    ```
        lcc.LOADTABLE_AUTO = true;
    ```
    默认为自动加载模式。

## **模块基础用法**

该模块主要的操作有加载数据表和引用数据表。

1. ### 创建数据表资源和配置文件
    `数据表资源和配置文件`应该是由配套的资源构建工具生成的，这里主要说明`数据表资源和配置文件`的格式和如何手动添加。<br/>
    所有`数据表资源和配置文件`都应该在分包目录下，`数据表资源文件`就是数据表内容JSON文件，`UI配置文件`就是数据表资源索引文件。<br/>
    下面的例子可以具体说明创建和配置的流程。<br/>
    比如在`resources`分包创建名为`testtable`的数据表，具体步骤如下；<br/>
    * 在`resources`分包目录下创建名为`testtable.json`的JSON文件。然后编辑该JSON文件内容如下：<br/>
        ```
            {
                "testtable": [
                    {
                        "id":"item1",
                        "name":"test", 
                        "value":1 
                    },
                    {
                        "id":"item2",
                        "name":"test2", 
                        "value":2 
                    }
                ]
            }
        ```
        其中`testtable`就是数据表名称，后面是数据表的内容。
    * 在`resources`分包目录下创建`table-indexs.json`数据表资源索引文件（也可以直接修改包内其他资源索引文件）。编辑该索引文件，在`table`索引路径下加入`testtable`数据表的配置，如下；<br/>
        ```
            {
                "table":{
                    "testtable":[
                        "asset://resources/testtable"
                    ]
                }
            }
        ```
        注意，具体数据表的配置是一个文件数组，因为这个数据表可能由多个文件合并而成。
    * 在`resources`分包根目录下创建`index-files.json`资源索引文件目录（如果不存在这个文件），然后把`table-indexs.json`数据表资源索引文件引用加入到`index-files.json`文件中，如下；<br/>
        ```
            {
                .... // 其他索引文件引用

                "table":"asset://resources/table-indexs"
            }
        ```
        至此，`testtable`数据表创建和配置完成。

2. ### 通过数据表名称加载数据表** `手动模式有效`<br/>
    手动模式，需要手动加载数据表。如下操作；<br/>
    ```
        // 可以一次性加载多个数据表
        await lcc.tableMgr.loadTable('game','test');
    ```
    由于数据表是分散到模块化分包中的，所以在调用`loadTable()`的时候，存在对应分包未加载的情况；但是没关系，调用`loadTable()`的时候也会标记对应数据表为已加载，当分包加载的时候会直接加载数据表。

3. ### 引用加载的数据表
    加载后的数据表都会被存进`lcc.TABLES`映射表中。所以我们可以直接通过`lcc.TABLES`和数据表名称引用数据表对象，如下操作：
    ```
        // 例如有名为test的配置对象在TABLES中
        let test = lcc.TABLES.test;       // 方式1
        let test = lcc.TABLES['test'];    // 方式2
    ```
    上面这种操作一般用于自动加载模式中，如果是手动加载模式，并且确定调用了`loadTable()`函数，也可以如此引用。<br/>
    否则，如果是手动加载模式，推荐使用`await getTable()`引用数据表，如下：<br/>
    ```
        // 例如有名为test的数据表对象在TABLES中
        let test = await lcc.tableMgr.getTable('test');
    ```
    在手动加载模式下，`await getTable()`引用数据表前，如果指定数据表未加载，那么会先去加载对应的数据表。

4. ### 数据表附带的声明文件
    如果是由当前框架配套资源构建工具生成的数据表，那么会附带数据表的声明文件`lcc-tables.d.ts`。
    把声明文件引入工程后（模板工程默认引入），就可以使用带有类型的数据表。如下：
    ``` 
        // 方式1    带有类型的数据表
        let test = <lcc$TABLES.test>lcc.TABLES['test'];

        // 方式2    带有类型的数据表
        let test = lcc.tableMgr.getTable<lcc$TABLES.test>('test');
    ```

5. ### 移除数据表对象** `手动模式有效`<br/>
    ```
    // 移除 test 数据表
    lcc.tableMgr.removeTable('test');

    // 移除所有数据表
    lcc.tableMgr.removeAllTables();
    ```
