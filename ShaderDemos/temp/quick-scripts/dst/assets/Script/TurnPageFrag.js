
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Script/TurnPageFrag.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '215f3EJr0ZPB7NfDgJ9xYCA', 'TurnPageFrag');
// Script/TurnPageFrag.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TurnPageFrag = /** @class */ (function () {
    function TurnPageFrag() {
    }
    TurnPageFrag.turnpage_vert = "\n    attribute vec4 a_position;\n    attribute vec2 a_texCoord;\n    attribute vec4 a_color;\n    varying vec2 v_texCoord;\n    varying vec4 v_fragmentColor;\n    void main()\n    {\n        gl_Position = CC_PMatrix * a_position;\n        v_fragmentColor = a_color;\n        v_texCoord = a_texCoord;\n    }\n    ";
    TurnPageFrag.turnpage_frag = "\n    uniform vec2 resolution;\n    uniform vec2 mouse;\n    varying vec2 v_texCoord;\n\n    const float pi = 3.14159;\n    const float twopi = 6.28319;\n\n    const float e0 = 0.018;\n    const float ppow = 2.0;\n\n    const float bcolorMix = 0.67;\n    const float maxBcolVal = 0.4;\n\n    const float diffint = 1.2;\n    const float ambientt = 0.1;\n    const float ambientb = 0.4;\n\n    const vec2 specpos = vec2(0.85, -0.2);\n    const float specpow = 5.;\n    const float specwidth = 0.4;\n    const float specint = 0.6;\n\n    const vec2 shadowoffset = vec2(0.07, -0.04);\n    const float shadowsmoothness = 0.012;\n    const float shadowint = 0.25;\n\n    const float aawidth = 0.7;\n    const int aasamples = 3;\n\n    const bool showpoints = false;\n    const bool colors = false;\n    const bool anim = true;\n\n    // #define swap_x\n    // Simple \"random\" function\n    float random(float co)\n    {\n        return fract(sin(co*12.989) * 43758.545);\n    }\n\n    vec4 getPagebackColor()\n    {\n        \n        float cn = 1.;\n        vec4 pagebackColor;\n        pagebackColor.r = maxBcolVal*random(cn + 263.714);\n        pagebackColor.g = maxBcolVal*random(cn*4. - 151.894);\n        pagebackColor.b = maxBcolVal*random(cn*7. + 87.548);\n        pagebackColor.a = 1.0;\n        return pagebackColor;\n    }\n\n    vec2 rotateVec(vec2 vect, float angle)\n    {\n        float xr = vect.x*cos(angle) + vect.y*sin(angle);\n        float yr = vect.x*sin(angle) - vect.y*cos(angle);\n        return vec2(xr, yr);\n    }\n\n    // Curl function on the axis bottom left corner - corner of the sheet\n    float pageFunction(float x, float e)\n    {\n        return pow(pow(x, ppow) - e, 1./ppow);\n    }\n\n    // Derivate of the curl function for light calculations\n    float pageFunctionDer(float x, float e)\n    {\n        return pow(x, ppow - 1.)/pow(pow(x, ppow) - e, (ppow - 1.)/ppow);\n    }\n\n    vec4 turnPage(vec2 fragCoord)\n    {\n        // General calculations\n        vec2 uv = v_texCoord.xy ;//fragCoord.xy / resolution.yy;\n        float ratio = resolution.x/resolution.y;\n        \n        // As long as one doesn't click on the canvas, the animation runs\n        vec2 mpoint;\n        bool firstcycle;\n        \n        vec2 Mouse2 = mouse;\n        #ifdef swap_x\n        Mouse2.x = resolution.x - Mouse2.x;\n        #endif\n        mpoint = Mouse2.xy;\n        firstcycle = true;\n        vec2 midmpoint = mpoint*0.5;\n        float mdist = distance(fragCoord, mpoint);\n        float e = e0*pow(mdist/resolution.y, 2.) + 0.02*e0*smoothstep(0., 0.12, mdist/resolution.y);\n        float angle = - atan(mpoint.x/mpoint.y) + pi*0.5;\n        \n        vec2 uv2 = uv;\n        #ifdef swap_x\n        uv2.x = ratio - uv2.x;\n        #endif\n        \n        vec2 uvr = rotateVec(uv2 - midmpoint/resolution.yy, angle);\n        \n        float pagefunc = pageFunction(uvr.x, e);\n        vec2 uvr2 = vec2(pagefunc, uvr.y); \n        vec2 uvr3 = rotateVec(uvr2, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\n        \n        vec2 uvr2b = vec2(-pagefunc, uvr.y); \n        vec2 uvr3b = rotateVec(uvr2b, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\n        \n        #ifdef swap_x\n        uvr3b.x = ratio - uvr3b.x;\n        #endif\n            \n        vec4 i; \n        // Turned page\n        if (uvr.x>0. && uvr3b.y>0.)\n        {\n            vec2 uvcorr = vec2(ratio, 1.);\n            vec2 uvrcorr = rotateVec(uvcorr - midmpoint/resolution.yy, angle);\n            float pagefunccorr = pageFunction(uvrcorr.x, e);\n            vec2 uvrcorr2 = vec2(-pagefunccorr, uvrcorr.y); \n            vec2 uvrcorr3 = rotateVec(uvrcorr2, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\n        \n            float pagefuncder = pageFunctionDer(uvr.x, e);\n            float intfac = 1. - diffint*(1. - 1./pagefuncder);\n\n            if(uvr3.x>=0. || uvr3.y<=0.)\n            {\n                // Top of the turned page           \n                float mdists = distance(fragCoord, mpoint)*0.7 - 55.;\n                float es = e0*pow(mdists/resolution.y, 2.) + 0.02*e0*smoothstep(0., 0.08, mdist/resolution.y);\n                vec2 uvrs = rotateVec(uv2 - midmpoint/resolution.yy - shadowoffset, angle);\n                float pagefuncs = pageFunction(uvrs.x + 0.015, es - 0.001);\n                vec2 uvr2s = vec2(pagefuncs, uvrs.y); \n                vec2 uvr3s = rotateVec(uvr2s, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\n                float shadow = 1. - (1. - smoothstep(-shadowsmoothness, shadowsmoothness, uvr3s.x))*(1. - smoothstep(shadowsmoothness, -shadowsmoothness, uvr3s.y));\n                \n                float difft = intfac*(1. - ambientt) + ambientt;\n                difft = difft*(shadow*shadowint + 1. - shadowint)/2. + mix(1. - shadowint, difft, shadow)/2.;\n                if (firstcycle)\n                    i = difft*(colors?vec4(1., 0.3, 0.3, 1.):texture2D(CC_Texture0, mod((uvr3b - uvrcorr3)/vec2(-ratio, 1.), 1.)));\n                else\n                    i = difft*(colors?vec4(1., 0.3, 0.3, 1.):texture2D(CC_Texture0, mod((uvr3b - uvrcorr3)/vec2(-ratio, 1.), 1.)));\n            }\n            else\n            {\n                // Bottom of the turned page\n                float diffb = intfac*(1. - ambientb) + ambientb;\n                float spec = pow(smoothstep(specpos.x - 0.35, specpos.x, intfac)*smoothstep(specpos.x + 0.35, specpos.x, intfac), specpow);\n                spec*= specint*pow(1. - pow(clamp(abs(uvr.y - specpos.y), 0., specwidth*2.), 2.)/specwidth, specpow);\n                if (firstcycle)\n                    i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(texture2D(CC_Texture0, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), getPagebackColor(), bcolorMix));\n                else\n                    i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(texture2D(CC_Texture0, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), getPagebackColor(), bcolorMix));\n                //i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):texture2D(iChannel1, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), vec4(0.3, 0., 0., 1.));\n                i = mix(i, vec4(1.0), spec);\n            }\n        }\n        else\n        {\n            // \"Background\" with simple shadow\n            vec2 mpointbg = vec2(0.2, 0.01);\n            vec2 midmpointbg = mpointbg*0.5;\n            float mdistbg = distance(fragCoord, mpointbg);\n            float ebg = e0*pow(mdistbg/resolution.y, 2.) + 0.01*e0*smoothstep(0., 0.12, mdistbg/resolution.y);\n            float anglebg = 0.001; //- atan(mpointbg.x/mpointbg.y) + pi*0.5;\n            vec2 uvrbg = rotateVec(uv - midmpointbg/resolution.yy, anglebg);\n            //float pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), clamp(uvrbg.x*5., 0., 1.));\n            float pagefuncbg;\n            if (uvrbg.x<0.15)\n            pagefuncbg = uvrbg.x;\n            else\n            pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), smoothstep(mpoint.x/resolution.x + 0.1, mpoint.x/resolution.x, uvrbg.x));\n            \n            vec2 uvr2bbg = vec2(-pagefuncbg, uvrbg.y); \n            vec2 uvr3bbg = rotateVec(uvr2bbg, -anglebg) - vec2(1., -1.)*midmpointbg/resolution.yy;\n            vec2 uvcorrbg = vec2(ratio, 1.);\n            vec2 uvrcorrbg = rotateVec(uvcorrbg - midmpointbg/resolution.yy, anglebg);\n            float pagefunccorrbg = pageFunction(uvrcorrbg.x, ebg);\n            vec2 uvrcorr2bg = vec2(-pagefunccorrbg, uvrcorrbg.y); \n            vec2 uvrcorr3bg = rotateVec(uvrcorr2bg, -anglebg) - vec2(1., -1.)*midmpointbg/resolution.yy;       \n            float pagefuncderbg = pageFunctionDer(uvrbg.x, ebg);\n            float intfacbg = 1. - diffint*(1. - 1./pagefuncderbg);\n            float difftbg = intfacbg*(1. - ambientt) + ambientt;\n            \n            if (firstcycle) \n                i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture2D(CC_Texture0, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\n            else\n                i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture2D(CC_Texture0, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\n            float bgshadow = 1. + shadowint*smoothstep(-0.08+shadowsmoothness*4., -0.08, uvr3b.y) - shadowint;\n            \n            if (uvr3b.y<0.)\n            i*= bgshadow;\n        }\n        return i;\n    }\n    \n    void mainImage(out vec4 fragColor, in vec2 fragCoord)\n    {\n        // Antialiasing\n        vec4 vs = vec4(0.);\n        for (int j=0;j<aasamples ;j++)\n        {\n        float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n        for (int i=0;i<aasamples ;i++)\n        {\n            float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n            vs+= turnPage(fragCoord + vec2(ox, oy));\n        }\n        }\n        vec4 i = vs/vec4(aasamples*aasamples);    \n        \n        // Show the mouse points. Was only used for development\n        vec4 ocol; \n        if (showpoints)\n        {\n            float ratio = resolution.x/resolution.y;\n            vec2 mpoint = mouse.xy;\n            vec2 midmpoint = mouse.xy*0.5;\n            float mdist = distance(fragCoord, mpoint);\n            float midmdist = distance(fragCoord, midmpoint);\n            \n            ocol = mix(i, vec4(1., 0., 0., 1.), smoothstep(6., 4., mdist));\n            ocol = mix(ocol, vec4(1., 1., 0., 1.), smoothstep(6., 4., midmdist));\n        }\n        else\n            ocol = i;\n            \n        fragColor = ocol;\n    }\n\n    void main()\n    {\n        mainImage(gl_FragColor, gl_FragCoord.xy);\n    }\n    ";
    return TurnPageFrag;
}());
exports.default = TurnPageFrag;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0XFxUdXJuUGFnZUZyYWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtJQUFBO0lBd1BBLENBQUM7SUF2UFUsMEJBQWEsR0FBRywyVEFZdEIsQ0FBQztJQUNLLDBCQUFhLEdBQUcseTNTQXlPdEIsQ0FBQztJQUNOLG1CQUFDO0NBeFBELEFBd1BDLElBQUE7a0JBeFBvQixZQUFZIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHVyblBhZ2VGcmFne1xyXG4gICAgc3RhdGljIHR1cm5wYWdlX3ZlcnQgPSBgXHJcbiAgICBhdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uO1xyXG4gICAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcclxuICAgIGF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XHJcbiAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcclxuICAgIHZhcnlpbmcgdmVjNCB2X2ZyYWdtZW50Q29sb3I7XHJcbiAgICB2b2lkIG1haW4oKVxyXG4gICAge1xyXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gQ0NfUE1hdHJpeCAqIGFfcG9zaXRpb247XHJcbiAgICAgICAgdl9mcmFnbWVudENvbG9yID0gYV9jb2xvcjtcclxuICAgICAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcclxuICAgIH1cclxuICAgIGA7XHJcbiAgICBzdGF0aWMgdHVybnBhZ2VfZnJhZyA9IGBcclxuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xyXG4gICAgdW5pZm9ybSB2ZWMyIG1vdXNlO1xyXG4gICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XHJcblxyXG4gICAgY29uc3QgZmxvYXQgcGkgPSAzLjE0MTU5O1xyXG4gICAgY29uc3QgZmxvYXQgdHdvcGkgPSA2LjI4MzE5O1xyXG5cclxuICAgIGNvbnN0IGZsb2F0IGUwID0gMC4wMTg7XHJcbiAgICBjb25zdCBmbG9hdCBwcG93ID0gMi4wO1xyXG5cclxuICAgIGNvbnN0IGZsb2F0IGJjb2xvck1peCA9IDAuNjc7XHJcbiAgICBjb25zdCBmbG9hdCBtYXhCY29sVmFsID0gMC40O1xyXG5cclxuICAgIGNvbnN0IGZsb2F0IGRpZmZpbnQgPSAxLjI7XHJcbiAgICBjb25zdCBmbG9hdCBhbWJpZW50dCA9IDAuMTtcclxuICAgIGNvbnN0IGZsb2F0IGFtYmllbnRiID0gMC40O1xyXG5cclxuICAgIGNvbnN0IHZlYzIgc3BlY3BvcyA9IHZlYzIoMC44NSwgLTAuMik7XHJcbiAgICBjb25zdCBmbG9hdCBzcGVjcG93ID0gNS47XHJcbiAgICBjb25zdCBmbG9hdCBzcGVjd2lkdGggPSAwLjQ7XHJcbiAgICBjb25zdCBmbG9hdCBzcGVjaW50ID0gMC42O1xyXG5cclxuICAgIGNvbnN0IHZlYzIgc2hhZG93b2Zmc2V0ID0gdmVjMigwLjA3LCAtMC4wNCk7XHJcbiAgICBjb25zdCBmbG9hdCBzaGFkb3dzbW9vdGhuZXNzID0gMC4wMTI7XHJcbiAgICBjb25zdCBmbG9hdCBzaGFkb3dpbnQgPSAwLjI1O1xyXG5cclxuICAgIGNvbnN0IGZsb2F0IGFhd2lkdGggPSAwLjc7XHJcbiAgICBjb25zdCBpbnQgYWFzYW1wbGVzID0gMztcclxuXHJcbiAgICBjb25zdCBib29sIHNob3dwb2ludHMgPSBmYWxzZTtcclxuICAgIGNvbnN0IGJvb2wgY29sb3JzID0gZmFsc2U7XHJcbiAgICBjb25zdCBib29sIGFuaW0gPSB0cnVlO1xyXG5cclxuICAgIC8vICNkZWZpbmUgc3dhcF94XHJcbiAgICAvLyBTaW1wbGUgXCJyYW5kb21cIiBmdW5jdGlvblxyXG4gICAgZmxvYXQgcmFuZG9tKGZsb2F0IGNvKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmcmFjdChzaW4oY28qMTIuOTg5KSAqIDQzNzU4LjU0NSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmVjNCBnZXRQYWdlYmFja0NvbG9yKClcclxuICAgIHtcclxuICAgICAgICBcclxuICAgICAgICBmbG9hdCBjbiA9IDEuO1xyXG4gICAgICAgIHZlYzQgcGFnZWJhY2tDb2xvcjtcclxuICAgICAgICBwYWdlYmFja0NvbG9yLnIgPSBtYXhCY29sVmFsKnJhbmRvbShjbiArIDI2My43MTQpO1xyXG4gICAgICAgIHBhZ2ViYWNrQ29sb3IuZyA9IG1heEJjb2xWYWwqcmFuZG9tKGNuKjQuIC0gMTUxLjg5NCk7XHJcbiAgICAgICAgcGFnZWJhY2tDb2xvci5iID0gbWF4QmNvbFZhbCpyYW5kb20oY24qNy4gKyA4Ny41NDgpO1xyXG4gICAgICAgIHBhZ2ViYWNrQ29sb3IuYSA9IDEuMDtcclxuICAgICAgICByZXR1cm4gcGFnZWJhY2tDb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICB2ZWMyIHJvdGF0ZVZlYyh2ZWMyIHZlY3QsIGZsb2F0IGFuZ2xlKVxyXG4gICAge1xyXG4gICAgICAgIGZsb2F0IHhyID0gdmVjdC54KmNvcyhhbmdsZSkgKyB2ZWN0Lnkqc2luKGFuZ2xlKTtcclxuICAgICAgICBmbG9hdCB5ciA9IHZlY3QueCpzaW4oYW5nbGUpIC0gdmVjdC55KmNvcyhhbmdsZSk7XHJcbiAgICAgICAgcmV0dXJuIHZlYzIoeHIsIHlyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDdXJsIGZ1bmN0aW9uIG9uIHRoZSBheGlzIGJvdHRvbSBsZWZ0IGNvcm5lciAtIGNvcm5lciBvZiB0aGUgc2hlZXRcclxuICAgIGZsb2F0IHBhZ2VGdW5jdGlvbihmbG9hdCB4LCBmbG9hdCBlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBwb3cocG93KHgsIHBwb3cpIC0gZSwgMS4vcHBvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVyaXZhdGUgb2YgdGhlIGN1cmwgZnVuY3Rpb24gZm9yIGxpZ2h0IGNhbGN1bGF0aW9uc1xyXG4gICAgZmxvYXQgcGFnZUZ1bmN0aW9uRGVyKGZsb2F0IHgsIGZsb2F0IGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHBvdyh4LCBwcG93IC0gMS4pL3Bvdyhwb3coeCwgcHBvdykgLSBlLCAocHBvdyAtIDEuKS9wcG93KTtcclxuICAgIH1cclxuXHJcbiAgICB2ZWM0IHR1cm5QYWdlKHZlYzIgZnJhZ0Nvb3JkKVxyXG4gICAge1xyXG4gICAgICAgIC8vIEdlbmVyYWwgY2FsY3VsYXRpb25zXHJcbiAgICAgICAgdmVjMiB1diA9IHZfdGV4Q29vcmQueHkgOy8vZnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbi55eTtcclxuICAgICAgICBmbG9hdCByYXRpbyA9IHJlc29sdXRpb24ueC9yZXNvbHV0aW9uLnk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQXMgbG9uZyBhcyBvbmUgZG9lc24ndCBjbGljayBvbiB0aGUgY2FudmFzLCB0aGUgYW5pbWF0aW9uIHJ1bnNcclxuICAgICAgICB2ZWMyIG1wb2ludDtcclxuICAgICAgICBib29sIGZpcnN0Y3ljbGU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmVjMiBNb3VzZTIgPSBtb3VzZTtcclxuICAgICAgICAjaWZkZWYgc3dhcF94XHJcbiAgICAgICAgTW91c2UyLnggPSByZXNvbHV0aW9uLnggLSBNb3VzZTIueDtcclxuICAgICAgICAjZW5kaWZcclxuICAgICAgICBtcG9pbnQgPSBNb3VzZTIueHk7XHJcbiAgICAgICAgZmlyc3RjeWNsZSA9IHRydWU7XHJcbiAgICAgICAgdmVjMiBtaWRtcG9pbnQgPSBtcG9pbnQqMC41O1xyXG4gICAgICAgIGZsb2F0IG1kaXN0ID0gZGlzdGFuY2UoZnJhZ0Nvb3JkLCBtcG9pbnQpO1xyXG4gICAgICAgIGZsb2F0IGUgPSBlMCpwb3cobWRpc3QvcmVzb2x1dGlvbi55LCAyLikgKyAwLjAyKmUwKnNtb290aHN0ZXAoMC4sIDAuMTIsIG1kaXN0L3Jlc29sdXRpb24ueSk7XHJcbiAgICAgICAgZmxvYXQgYW5nbGUgPSAtIGF0YW4obXBvaW50LngvbXBvaW50LnkpICsgcGkqMC41O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZlYzIgdXYyID0gdXY7XHJcbiAgICAgICAgI2lmZGVmIHN3YXBfeFxyXG4gICAgICAgIHV2Mi54ID0gcmF0aW8gLSB1djIueDtcclxuICAgICAgICAjZW5kaWZcclxuICAgICAgICBcclxuICAgICAgICB2ZWMyIHV2ciA9IHJvdGF0ZVZlYyh1djIgLSBtaWRtcG9pbnQvcmVzb2x1dGlvbi55eSwgYW5nbGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZsb2F0IHBhZ2VmdW5jID0gcGFnZUZ1bmN0aW9uKHV2ci54LCBlKTtcclxuICAgICAgICB2ZWMyIHV2cjIgPSB2ZWMyKHBhZ2VmdW5jLCB1dnIueSk7IFxyXG4gICAgICAgIHZlYzIgdXZyMyA9IHJvdGF0ZVZlYyh1dnIyLCAtYW5nbGUpIC0gdmVjMigxLiwgLTEuKSptaWRtcG9pbnQvcmVzb2x1dGlvbi55eTtcclxuICAgICAgICBcclxuICAgICAgICB2ZWMyIHV2cjJiID0gdmVjMigtcGFnZWZ1bmMsIHV2ci55KTsgXHJcbiAgICAgICAgdmVjMiB1dnIzYiA9IHJvdGF0ZVZlYyh1dnIyYiwgLWFuZ2xlKSAtIHZlYzIoMS4sIC0xLikqbWlkbXBvaW50L3Jlc29sdXRpb24ueXk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgI2lmZGVmIHN3YXBfeFxyXG4gICAgICAgIHV2cjNiLnggPSByYXRpbyAtIHV2cjNiLng7XHJcbiAgICAgICAgI2VuZGlmXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIHZlYzQgaTsgXHJcbiAgICAgICAgLy8gVHVybmVkIHBhZ2VcclxuICAgICAgICBpZiAodXZyLng+MC4gJiYgdXZyM2IueT4wLilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZlYzIgdXZjb3JyID0gdmVjMihyYXRpbywgMS4pO1xyXG4gICAgICAgICAgICB2ZWMyIHV2cmNvcnIgPSByb3RhdGVWZWModXZjb3JyIC0gbWlkbXBvaW50L3Jlc29sdXRpb24ueXksIGFuZ2xlKTtcclxuICAgICAgICAgICAgZmxvYXQgcGFnZWZ1bmNjb3JyID0gcGFnZUZ1bmN0aW9uKHV2cmNvcnIueCwgZSk7XHJcbiAgICAgICAgICAgIHZlYzIgdXZyY29ycjIgPSB2ZWMyKC1wYWdlZnVuY2NvcnIsIHV2cmNvcnIueSk7IFxyXG4gICAgICAgICAgICB2ZWMyIHV2cmNvcnIzID0gcm90YXRlVmVjKHV2cmNvcnIyLCAtYW5nbGUpIC0gdmVjMigxLiwgLTEuKSptaWRtcG9pbnQvcmVzb2x1dGlvbi55eTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgZmxvYXQgcGFnZWZ1bmNkZXIgPSBwYWdlRnVuY3Rpb25EZXIodXZyLngsIGUpO1xyXG4gICAgICAgICAgICBmbG9hdCBpbnRmYWMgPSAxLiAtIGRpZmZpbnQqKDEuIC0gMS4vcGFnZWZ1bmNkZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYodXZyMy54Pj0wLiB8fCB1dnIzLnk8PTAuKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUb3Agb2YgdGhlIHR1cm5lZCBwYWdlICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZsb2F0IG1kaXN0cyA9IGRpc3RhbmNlKGZyYWdDb29yZCwgbXBvaW50KSowLjcgLSA1NS47XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBlcyA9IGUwKnBvdyhtZGlzdHMvcmVzb2x1dGlvbi55LCAyLikgKyAwLjAyKmUwKnNtb290aHN0ZXAoMC4sIDAuMDgsIG1kaXN0L3Jlc29sdXRpb24ueSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMyIHV2cnMgPSByb3RhdGVWZWModXYyIC0gbWlkbXBvaW50L3Jlc29sdXRpb24ueXkgLSBzaGFkb3dvZmZzZXQsIGFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHBhZ2VmdW5jcyA9IHBhZ2VGdW5jdGlvbih1dnJzLnggKyAwLjAxNSwgZXMgLSAwLjAwMSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMyIHV2cjJzID0gdmVjMihwYWdlZnVuY3MsIHV2cnMueSk7IFxyXG4gICAgICAgICAgICAgICAgdmVjMiB1dnIzcyA9IHJvdGF0ZVZlYyh1dnIycywgLWFuZ2xlKSAtIHZlYzIoMS4sIC0xLikqbWlkbXBvaW50L3Jlc29sdXRpb24ueXk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBzaGFkb3cgPSAxLiAtICgxLiAtIHNtb290aHN0ZXAoLXNoYWRvd3Ntb290aG5lc3MsIHNoYWRvd3Ntb290aG5lc3MsIHV2cjNzLngpKSooMS4gLSBzbW9vdGhzdGVwKHNoYWRvd3Ntb290aG5lc3MsIC1zaGFkb3dzbW9vdGhuZXNzLCB1dnIzcy55KSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRpZmZ0ID0gaW50ZmFjKigxLiAtIGFtYmllbnR0KSArIGFtYmllbnR0O1xyXG4gICAgICAgICAgICAgICAgZGlmZnQgPSBkaWZmdCooc2hhZG93KnNoYWRvd2ludCArIDEuIC0gc2hhZG93aW50KS8yLiArIG1peCgxLiAtIHNoYWRvd2ludCwgZGlmZnQsIHNoYWRvdykvMi47XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RjeWNsZSlcclxuICAgICAgICAgICAgICAgICAgICBpID0gZGlmZnQqKGNvbG9ycz92ZWM0KDEuLCAwLjMsIDAuMywgMS4pOnRleHR1cmUyRChDQ19UZXh0dXJlMCwgbW9kKCh1dnIzYiAtIHV2cmNvcnIzKS92ZWMyKC1yYXRpbywgMS4pLCAxLikpKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBpID0gZGlmZnQqKGNvbG9ycz92ZWM0KDEuLCAwLjMsIDAuMywgMS4pOnRleHR1cmUyRChDQ19UZXh0dXJlMCwgbW9kKCh1dnIzYiAtIHV2cmNvcnIzKS92ZWMyKC1yYXRpbywgMS4pLCAxLikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEJvdHRvbSBvZiB0aGUgdHVybmVkIHBhZ2VcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRpZmZiID0gaW50ZmFjKigxLiAtIGFtYmllbnRiKSArIGFtYmllbnRiO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgc3BlYyA9IHBvdyhzbW9vdGhzdGVwKHNwZWNwb3MueCAtIDAuMzUsIHNwZWNwb3MueCwgaW50ZmFjKSpzbW9vdGhzdGVwKHNwZWNwb3MueCArIDAuMzUsIHNwZWNwb3MueCwgaW50ZmFjKSwgc3BlY3Bvdyk7XHJcbiAgICAgICAgICAgICAgICBzcGVjKj0gc3BlY2ludCpwb3coMS4gLSBwb3coY2xhbXAoYWJzKHV2ci55IC0gc3BlY3Bvcy55KSwgMC4sIHNwZWN3aWR0aCoyLiksIDIuKS9zcGVjd2lkdGgsIHNwZWNwb3cpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Y3ljbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IGRpZmZiKihjb2xvcnM/dmVjNCgwLjMsIDEuMCwgMC4zLCAxLik6bWl4KHRleHR1cmUyRChDQ19UZXh0dXJlMCwgbW9kKCh1dnIzIC0gdXZyY29ycjMpL3ZlYzIoLXJhdGlvLCAxLiksIDEuKSksIGdldFBhZ2ViYWNrQ29sb3IoKSwgYmNvbG9yTWl4KSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IGRpZmZiKihjb2xvcnM/dmVjNCgwLjMsIDEuMCwgMC4zLCAxLik6bWl4KHRleHR1cmUyRChDQ19UZXh0dXJlMCwgbW9kKCh1dnIzIC0gdXZyY29ycjMpL3ZlYzIoLXJhdGlvLCAxLiksIDEuKSksIGdldFBhZ2ViYWNrQ29sb3IoKSwgYmNvbG9yTWl4KSk7XHJcbiAgICAgICAgICAgICAgICAvL2kgPSBkaWZmYiooY29sb3JzP3ZlYzQoMC4zLCAxLjAsIDAuMywgMS4pOnRleHR1cmUyRChpQ2hhbm5lbDEsIG1vZCgodXZyMyAtIHV2cmNvcnIzKS92ZWMyKC1yYXRpbywgMS4pLCAxLikpLCB2ZWM0KDAuMywgMC4sIDAuLCAxLikpO1xyXG4gICAgICAgICAgICAgICAgaSA9IG1peChpLCB2ZWM0KDEuMCksIHNwZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFwiQmFja2dyb3VuZFwiIHdpdGggc2ltcGxlIHNoYWRvd1xyXG4gICAgICAgICAgICB2ZWMyIG1wb2ludGJnID0gdmVjMigwLjIsIDAuMDEpO1xyXG4gICAgICAgICAgICB2ZWMyIG1pZG1wb2ludGJnID0gbXBvaW50YmcqMC41O1xyXG4gICAgICAgICAgICBmbG9hdCBtZGlzdGJnID0gZGlzdGFuY2UoZnJhZ0Nvb3JkLCBtcG9pbnRiZyk7XHJcbiAgICAgICAgICAgIGZsb2F0IGViZyA9IGUwKnBvdyhtZGlzdGJnL3Jlc29sdXRpb24ueSwgMi4pICsgMC4wMSplMCpzbW9vdGhzdGVwKDAuLCAwLjEyLCBtZGlzdGJnL3Jlc29sdXRpb24ueSk7XHJcbiAgICAgICAgICAgIGZsb2F0IGFuZ2xlYmcgPSAwLjAwMTsgLy8tIGF0YW4obXBvaW50YmcueC9tcG9pbnRiZy55KSArIHBpKjAuNTtcclxuICAgICAgICAgICAgdmVjMiB1dnJiZyA9IHJvdGF0ZVZlYyh1diAtIG1pZG1wb2ludGJnL3Jlc29sdXRpb24ueXksIGFuZ2xlYmcpO1xyXG4gICAgICAgICAgICAvL2Zsb2F0IHBhZ2VmdW5jYmcgPSBtaXgodXZyYmcueCwgcGFnZUZ1bmN0aW9uKHV2cmJnLngsIGViZyksIGNsYW1wKHV2cmJnLngqNS4sIDAuLCAxLikpO1xyXG4gICAgICAgICAgICBmbG9hdCBwYWdlZnVuY2JnO1xyXG4gICAgICAgICAgICBpZiAodXZyYmcueDwwLjE1KVxyXG4gICAgICAgICAgICBwYWdlZnVuY2JnID0gdXZyYmcueDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBwYWdlZnVuY2JnID0gbWl4KHV2cmJnLngsIHBhZ2VGdW5jdGlvbih1dnJiZy54LCBlYmcpLCBzbW9vdGhzdGVwKG1wb2ludC54L3Jlc29sdXRpb24ueCArIDAuMSwgbXBvaW50LngvcmVzb2x1dGlvbi54LCB1dnJiZy54KSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2ZWMyIHV2cjJiYmcgPSB2ZWMyKC1wYWdlZnVuY2JnLCB1dnJiZy55KTsgXHJcbiAgICAgICAgICAgIHZlYzIgdXZyM2JiZyA9IHJvdGF0ZVZlYyh1dnIyYmJnLCAtYW5nbGViZykgLSB2ZWMyKDEuLCAtMS4pKm1pZG1wb2ludGJnL3Jlc29sdXRpb24ueXk7XHJcbiAgICAgICAgICAgIHZlYzIgdXZjb3JyYmcgPSB2ZWMyKHJhdGlvLCAxLik7XHJcbiAgICAgICAgICAgIHZlYzIgdXZyY29ycmJnID0gcm90YXRlVmVjKHV2Y29ycmJnIC0gbWlkbXBvaW50YmcvcmVzb2x1dGlvbi55eSwgYW5nbGViZyk7XHJcbiAgICAgICAgICAgIGZsb2F0IHBhZ2VmdW5jY29ycmJnID0gcGFnZUZ1bmN0aW9uKHV2cmNvcnJiZy54LCBlYmcpO1xyXG4gICAgICAgICAgICB2ZWMyIHV2cmNvcnIyYmcgPSB2ZWMyKC1wYWdlZnVuY2NvcnJiZywgdXZyY29ycmJnLnkpOyBcclxuICAgICAgICAgICAgdmVjMiB1dnJjb3JyM2JnID0gcm90YXRlVmVjKHV2cmNvcnIyYmcsIC1hbmdsZWJnKSAtIHZlYzIoMS4sIC0xLikqbWlkbXBvaW50YmcvcmVzb2x1dGlvbi55eTsgICAgICAgXHJcbiAgICAgICAgICAgIGZsb2F0IHBhZ2VmdW5jZGVyYmcgPSBwYWdlRnVuY3Rpb25EZXIodXZyYmcueCwgZWJnKTtcclxuICAgICAgICAgICAgZmxvYXQgaW50ZmFjYmcgPSAxLiAtIGRpZmZpbnQqKDEuIC0gMS4vcGFnZWZ1bmNkZXJiZyk7XHJcbiAgICAgICAgICAgIGZsb2F0IGRpZmZ0YmcgPSBpbnRmYWNiZyooMS4gLSBhbWJpZW50dCkgKyBhbWJpZW50dDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChmaXJzdGN5Y2xlKSBcclxuICAgICAgICAgICAgICAgIGkgPSBjb2xvcnM/ZGlmZnRiZyp2ZWM0KDAuMywgMC4zLCAxLiwgMS4pOnRleHR1cmUyRChDQ19UZXh0dXJlMCwgbW9kKCh1dnIzYmJnIC0gdXZyY29ycjNiZykvdmVjMigtcmF0aW8sIDEuKSwgMS4pKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgaSA9IGNvbG9ycz9kaWZmdGJnKnZlYzQoMC4zLCAwLjMsIDEuLCAxLik6dGV4dHVyZTJEKENDX1RleHR1cmUwLCBtb2QoKHV2cjNiYmcgLSB1dnJjb3JyM2JnKS92ZWMyKC1yYXRpbywgMS4pLCAxLikpO1xyXG4gICAgICAgICAgICBmbG9hdCBiZ3NoYWRvdyA9IDEuICsgc2hhZG93aW50KnNtb290aHN0ZXAoLTAuMDgrc2hhZG93c21vb3RobmVzcyo0LiwgLTAuMDgsIHV2cjNiLnkpIC0gc2hhZG93aW50O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHV2cjNiLnk8MC4pXHJcbiAgICAgICAgICAgIGkqPSBiZ3NoYWRvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZvaWQgbWFpbkltYWdlKG91dCB2ZWM0IGZyYWdDb2xvciwgaW4gdmVjMiBmcmFnQ29vcmQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gQW50aWFsaWFzaW5nXHJcbiAgICAgICAgdmVjNCB2cyA9IHZlYzQoMC4pO1xyXG4gICAgICAgIGZvciAoaW50IGo9MDtqPGFhc2FtcGxlcyA7aisrKVxyXG4gICAgICAgIHtcclxuICAgICAgICBmbG9hdCBveSA9IGZsb2F0KGopKmFhd2lkdGgvbWF4KGZsb2F0KGFhc2FtcGxlcy0xKSwgMS4pO1xyXG4gICAgICAgIGZvciAoaW50IGk9MDtpPGFhc2FtcGxlcyA7aSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgb3ggPSBmbG9hdChpKSphYXdpZHRoL21heChmbG9hdChhYXNhbXBsZXMtMSksIDEuKTtcclxuICAgICAgICAgICAgdnMrPSB0dXJuUGFnZShmcmFnQ29vcmQgKyB2ZWMyKG94LCBveSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjNCBpID0gdnMvdmVjNChhYXNhbXBsZXMqYWFzYW1wbGVzKTsgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2hvdyB0aGUgbW91c2UgcG9pbnRzLiBXYXMgb25seSB1c2VkIGZvciBkZXZlbG9wbWVudFxyXG4gICAgICAgIHZlYzQgb2NvbDsgXHJcbiAgICAgICAgaWYgKHNob3dwb2ludHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCByYXRpbyA9IHJlc29sdXRpb24ueC9yZXNvbHV0aW9uLnk7XHJcbiAgICAgICAgICAgIHZlYzIgbXBvaW50ID0gbW91c2UueHk7XHJcbiAgICAgICAgICAgIHZlYzIgbWlkbXBvaW50ID0gbW91c2UueHkqMC41O1xyXG4gICAgICAgICAgICBmbG9hdCBtZGlzdCA9IGRpc3RhbmNlKGZyYWdDb29yZCwgbXBvaW50KTtcclxuICAgICAgICAgICAgZmxvYXQgbWlkbWRpc3QgPSBkaXN0YW5jZShmcmFnQ29vcmQsIG1pZG1wb2ludCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBvY29sID0gbWl4KGksIHZlYzQoMS4sIDAuLCAwLiwgMS4pLCBzbW9vdGhzdGVwKDYuLCA0LiwgbWRpc3QpKTtcclxuICAgICAgICAgICAgb2NvbCA9IG1peChvY29sLCB2ZWM0KDEuLCAxLiwgMC4sIDEuKSwgc21vb3Roc3RlcCg2LiwgNC4sIG1pZG1kaXN0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgb2NvbCA9IGk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGZyYWdDb2xvciA9IG9jb2w7XHJcbiAgICB9XHJcblxyXG4gICAgdm9pZCBtYWluKClcclxuICAgIHtcclxuICAgICAgICBtYWluSW1hZ2UoZ2xfRnJhZ0NvbG9yLCBnbF9GcmFnQ29vcmQueHkpO1xyXG4gICAgfVxyXG4gICAgYDtcclxufSJdfQ==