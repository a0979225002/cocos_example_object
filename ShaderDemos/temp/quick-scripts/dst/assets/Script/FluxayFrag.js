
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Script/FluxayFrag.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '47640HOQ1ZDg7T5phsuLF1h', 'FluxayFrag');
// Script/FluxayFrag.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Feofox Game
// Author:Lerry
// https://github.com/fylz1125/ShaderDemos
var FluxayFrag = /** @class */ (function () {
    function FluxayFrag() {
    }
    FluxayFrag.fluxay_vert = "\n    attribute vec4 a_position;\n    attribute vec2 a_texCoord;\n    attribute vec4 a_color;\n    varying vec2 v_texCoord;\n    varying vec4 v_fragmentColor;\n    void main()\n    {\n        gl_Position = CC_PMatrix * a_position;\n        v_fragmentColor = a_color;\n        v_texCoord = a_texCoord;\n    }\n    ";
    // 流光特效
    FluxayFrag.fluxay_frag = "\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    varying vec2 v_texCoord;\n    uniform float time;\n    void main()\n    {\n        vec4 src_color = texture2D(CC_Texture0, v_texCoord).rgba;\n\n        float width = 0.02;       //\u6D41\u5149\u7684\u5BBD\u5EA6\u8303\u56F4 (\u8C03\u6574\u8BE5\u503C\u6539\u53D8\u6D41\u5149\u7684\u5BBD\u5EA6)\n        float start = tan(time/1.414);  //\u6D41\u5149\u7684\u8D77\u59CBx\u5750\u6807\n        float strength = 0.006;   //\u6D41\u5149\u589E\u4EAE\u5F3A\u5EA6   (\u8C03\u6574\u8BE5\u503C\u6539\u53D8\u6D41\u5149\u7684\u589E\u4EAE\u5F3A\u5EA6)\n        float offset = 0.5;      //\u504F\u79FB\u503C         (\u8C03\u6574\u8BE5\u503C\u6539\u53D8\u6D41\u5149\u7684\u503E\u659C\u7A0B\u5EA6)\n        if( v_texCoord.x < (start - offset * v_texCoord.y) &&  v_texCoord.x > (start - offset * v_texCoord.y - width))\n        {\n            vec3 improve = strength * vec3(255, 255, 255);\n            vec3 result = improve * vec3( src_color.r, src_color.g, src_color.b);\n            gl_FragColor = vec4(result, src_color.a);\n\n        }else{\n            gl_FragColor = src_color;\n        }\n    }\n    ";
    // 流光的另一种写法
    FluxayFrag.fluxay_frag_s = "\n    #ifdef GL_ES                                 \n    precision mediump float;                          \n    #endif                                          \n    \n    varying vec4 v_fragmentColor;                  \n    varying vec2 v_texCoord;                      \n    \n    // uniform float factor;  \n    // uniform float width;  \n    uniform float time;  \n    // uniform vec3 color; \n    void main()                                      \n    {   \n        float factor = .06;\n        float width = .02;\n        // float offset = .5;\n        vec3 color = vec3(10.,10.,10.);                                           \n        vec4 texColor = texture2D(CC_Texture0, v_texCoord);  \n    \n        float distance = abs(v_texCoord[0]+v_texCoord[1]-tan(time))/1.414;   \n\n        distance = 1.0-(1.0/width)*distance;  \n        distance = max(distance, 0.0);  \n        vec4 sample = vec4(0.0,0.0,0.0,0.0);  \n        sample[0] = color[0] * distance;  \n        sample[1] = color[1] * distance;  \n        sample[2] = color[2] * distance;  \n        sample[3] = distance;  \n\n        float alpha = sample[3]*texColor[3];  \n        texColor[0] = texColor[0] + sample[0]*alpha*factor;  \n        texColor[1] = texColor[1] + sample[1]*alpha*factor;  \n        texColor[2] = texColor[2] + sample[2]*alpha*factor;  \n        gl_FragColor = v_fragmentColor * texColor;  \n    }\n     ";
    // 波光特效
    FluxayFrag.fluxay_frag_super = "\n    #define TAU 6.120470874064187\n    #define MAX_ITER 5\n    uniform float time; \n    varying vec2 v_texCoord;\n    varying vec4 v_fragmentColor;\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n    {\n        float time = time * .5+5.;\n        // uv should be the 0-1 uv of texture...\n        vec2 uv = v_texCoord.xy;//fragCoord.xy / iResolution.xy;\n        \n\n        vec2 p = mod(uv*TAU, TAU)-250.0;\n\n        vec2 i = vec2(p);\n        float c = 1.0;\n        float inten = .0045;\n\n        for (int n = 0; n < MAX_ITER; n++) \n        {\n            float t =  time * (1.0 - (3.5 / float(n+1)));\n            i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(1.5*t + i.x));\n            c += 1.0/length(vec2(p.x / (cos(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n        }\n        c /= float(MAX_ITER);\n        c = 1.17-pow(c, 1.4);\n        vec4 tex = texture2D(CC_Texture0,uv);\n        vec3 colour = vec3(pow(abs(c), 20.0));\n        colour = clamp(colour + vec3(0.0, 0.0, .0), 0.0, tex.a);\n\n        // \u6DF7\u5408\u6CE2\u5149\n        float alpha = c*tex[3];  \n        tex[0] = tex[0] + colour[0]*alpha; \n        tex[1] = tex[1] + colour[1]*alpha; \n        tex[2] = tex[2] + colour[2]*alpha; \n        fragColor = v_fragmentColor * tex;\n    }\n    void main()\n    {\n        mainImage(gl_FragColor, gl_FragCoord.xy);\n    }\n    ";
    return FluxayFrag;
}());
exports.default = FluxayFrag;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0XFxGbHV4YXlGcmFnLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsY0FBYztBQUNkLGVBQWU7QUFDZiwwQ0FBMEM7QUFDMUM7SUFBQTtJQTRIQSxDQUFDO0lBM0hVLHNCQUFXLEdBQUcsMlRBWXBCLENBQUM7SUFFRixPQUFPO0lBQ0Esc0JBQVcsR0FBRyxxb0NBd0JwQixDQUFDO0lBRUYsV0FBVztJQUNKLHdCQUFhLEdBQUcsbzNDQW9DckIsQ0FBQztJQUNILE9BQU87SUFDQSw0QkFBaUIsR0FBRyx5MkNBMEMxQixDQUFDO0lBQ04saUJBQUM7Q0E1SEQsQUE0SEMsSUFBQTtrQkE1SG9CLFVBQVUiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGZW9mb3ggR2FtZVxyXG4vLyBBdXRob3I6TGVycnlcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z5bHoxMTI1L1NoYWRlckRlbW9zXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsdXhheUZyYWd7XHJcbiAgICBzdGF0aWMgZmx1eGF5X3ZlcnQgPSBgXHJcbiAgICBhdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uO1xyXG4gICAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcclxuICAgIGF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XHJcbiAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcclxuICAgIHZhcnlpbmcgdmVjNCB2X2ZyYWdtZW50Q29sb3I7XHJcbiAgICB2b2lkIG1haW4oKVxyXG4gICAge1xyXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gQ0NfUE1hdHJpeCAqIGFfcG9zaXRpb247XHJcbiAgICAgICAgdl9mcmFnbWVudENvbG9yID0gYV9jb2xvcjtcclxuICAgICAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcclxuICAgIH1cclxuICAgIGA7XHJcblxyXG4gICAgLy8g5rWB5YWJ54m55pWIXHJcbiAgICBzdGF0aWMgZmx1eGF5X2ZyYWcgPSBgXHJcbiAgICAjaWZkZWYgR0xfRVNcclxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgI2VuZGlmXHJcbiAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcclxuICAgIHVuaWZvcm0gZmxvYXQgdGltZTtcclxuICAgIHZvaWQgbWFpbigpXHJcbiAgICB7XHJcbiAgICAgICAgdmVjNCBzcmNfY29sb3IgPSB0ZXh0dXJlMkQoQ0NfVGV4dHVyZTAsIHZfdGV4Q29vcmQpLnJnYmE7XHJcblxyXG4gICAgICAgIGZsb2F0IHdpZHRoID0gMC4wMjsgICAgICAgLy/mtYHlhYnnmoTlrr3luqbojIPlm7QgKOiwg+aVtOivpeWAvOaUueWPmOa1geWFieeahOWuveW6pilcclxuICAgICAgICBmbG9hdCBzdGFydCA9IHRhbih0aW1lLzEuNDE0KTsgIC8v5rWB5YWJ55qE6LW35aeLeOWdkOagh1xyXG4gICAgICAgIGZsb2F0IHN0cmVuZ3RoID0gMC4wMDY7ICAgLy/mtYHlhYnlop7kuq7lvLrluqYgICAo6LCD5pW06K+l5YC85pS55Y+Y5rWB5YWJ55qE5aKe5Lqu5by65bqmKVxyXG4gICAgICAgIGZsb2F0IG9mZnNldCA9IDAuNTsgICAgICAvL+WBj+enu+WAvCAgICAgICAgICjosIPmlbTor6XlgLzmlLnlj5jmtYHlhYnnmoTlgL7mlpznqIvluqYpXHJcbiAgICAgICAgaWYoIHZfdGV4Q29vcmQueCA8IChzdGFydCAtIG9mZnNldCAqIHZfdGV4Q29vcmQueSkgJiYgIHZfdGV4Q29vcmQueCA+IChzdGFydCAtIG9mZnNldCAqIHZfdGV4Q29vcmQueSAtIHdpZHRoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZlYzMgaW1wcm92ZSA9IHN0cmVuZ3RoICogdmVjMygyNTUsIDI1NSwgMjU1KTtcclxuICAgICAgICAgICAgdmVjMyByZXN1bHQgPSBpbXByb3ZlICogdmVjMyggc3JjX2NvbG9yLnIsIHNyY19jb2xvci5nLCBzcmNfY29sb3IuYik7XHJcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocmVzdWx0LCBzcmNfY29sb3IuYSk7XHJcblxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBzcmNfY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYDtcclxuXHJcbiAgICAvLyDmtYHlhYnnmoTlj6bkuIDnp43lhpnms5VcclxuICAgIHN0YXRpYyBmbHV4YXlfZnJhZ19zID0gYFxyXG4gICAgI2lmZGVmIEdMX0VTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgI2VuZGlmICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICBcclxuICAgIHZhcnlpbmcgdmVjNCB2X2ZyYWdtZW50Q29sb3I7ICAgICAgICAgICAgICAgICAgXHJcbiAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDsgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICBcclxuICAgIC8vIHVuaWZvcm0gZmxvYXQgZmFjdG9yOyAgXHJcbiAgICAvLyB1bmlmb3JtIGZsb2F0IHdpZHRoOyAgXHJcbiAgICB1bmlmb3JtIGZsb2F0IHRpbWU7ICBcclxuICAgIC8vIHVuaWZvcm0gdmVjMyBjb2xvcjsgXHJcbiAgICB2b2lkIG1haW4oKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICB7ICAgXHJcbiAgICAgICAgZmxvYXQgZmFjdG9yID0gLjA2O1xyXG4gICAgICAgIGZsb2F0IHdpZHRoID0gLjAyO1xyXG4gICAgICAgIC8vIGZsb2F0IG9mZnNldCA9IC41O1xyXG4gICAgICAgIHZlYzMgY29sb3IgPSB2ZWMzKDEwLiwxMC4sMTAuKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRChDQ19UZXh0dXJlMCwgdl90ZXhDb29yZCk7ICBcclxuICAgIFxyXG4gICAgICAgIGZsb2F0IGRpc3RhbmNlID0gYWJzKHZfdGV4Q29vcmRbMF0rdl90ZXhDb29yZFsxXS10YW4odGltZSkpLzEuNDE0OyAgIFxyXG5cclxuICAgICAgICBkaXN0YW5jZSA9IDEuMC0oMS4wL3dpZHRoKSpkaXN0YW5jZTsgIFxyXG4gICAgICAgIGRpc3RhbmNlID0gbWF4KGRpc3RhbmNlLCAwLjApOyAgXHJcbiAgICAgICAgdmVjNCBzYW1wbGUgPSB2ZWM0KDAuMCwwLjAsMC4wLDAuMCk7ICBcclxuICAgICAgICBzYW1wbGVbMF0gPSBjb2xvclswXSAqIGRpc3RhbmNlOyAgXHJcbiAgICAgICAgc2FtcGxlWzFdID0gY29sb3JbMV0gKiBkaXN0YW5jZTsgIFxyXG4gICAgICAgIHNhbXBsZVsyXSA9IGNvbG9yWzJdICogZGlzdGFuY2U7ICBcclxuICAgICAgICBzYW1wbGVbM10gPSBkaXN0YW5jZTsgIFxyXG5cclxuICAgICAgICBmbG9hdCBhbHBoYSA9IHNhbXBsZVszXSp0ZXhDb2xvclszXTsgIFxyXG4gICAgICAgIHRleENvbG9yWzBdID0gdGV4Q29sb3JbMF0gKyBzYW1wbGVbMF0qYWxwaGEqZmFjdG9yOyAgXHJcbiAgICAgICAgdGV4Q29sb3JbMV0gPSB0ZXhDb2xvclsxXSArIHNhbXBsZVsxXSphbHBoYSpmYWN0b3I7ICBcclxuICAgICAgICB0ZXhDb2xvclsyXSA9IHRleENvbG9yWzJdICsgc2FtcGxlWzJdKmFscGhhKmZhY3RvcjsgIFxyXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZfZnJhZ21lbnRDb2xvciAqIHRleENvbG9yOyAgXHJcbiAgICB9XHJcbiAgICAgYDtcclxuICAgIC8vIOazouWFieeJueaViFxyXG4gICAgc3RhdGljIGZsdXhheV9mcmFnX3N1cGVyID0gYFxyXG4gICAgI2RlZmluZSBUQVUgNi4xMjA0NzA4NzQwNjQxODdcclxuICAgICNkZWZpbmUgTUFYX0lURVIgNVxyXG4gICAgdW5pZm9ybSBmbG9hdCB0aW1lOyBcclxuICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xyXG4gICAgdmFyeWluZyB2ZWM0IHZfZnJhZ21lbnRDb2xvcjtcclxuICAgIHZvaWQgbWFpbkltYWdlKCBvdXQgdmVjNCBmcmFnQ29sb3IsIGluIHZlYzIgZnJhZ0Nvb3JkICkgXHJcbiAgICB7XHJcbiAgICAgICAgZmxvYXQgdGltZSA9IHRpbWUgKiAuNSs1LjtcclxuICAgICAgICAvLyB1diBzaG91bGQgYmUgdGhlIDAtMSB1diBvZiB0ZXh0dXJlLi4uXHJcbiAgICAgICAgdmVjMiB1diA9IHZfdGV4Q29vcmQueHk7Ly9mcmFnQ29vcmQueHkgLyBpUmVzb2x1dGlvbi54eTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgdmVjMiBwID0gbW9kKHV2KlRBVSwgVEFVKS0yNTAuMDtcclxuXHJcbiAgICAgICAgdmVjMiBpID0gdmVjMihwKTtcclxuICAgICAgICBmbG9hdCBjID0gMS4wO1xyXG4gICAgICAgIGZsb2F0IGludGVuID0gLjAwNDU7XHJcblxyXG4gICAgICAgIGZvciAoaW50IG4gPSAwOyBuIDwgTUFYX0lURVI7IG4rKykgXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCB0ID0gIHRpbWUgKiAoMS4wIC0gKDMuNSAvIGZsb2F0KG4rMSkpKTtcclxuICAgICAgICAgICAgaSA9IHAgKyB2ZWMyKGNvcyh0IC0gaS54KSArIHNpbih0ICsgaS55KSwgc2luKHQgLSBpLnkpICsgY29zKDEuNSp0ICsgaS54KSk7XHJcbiAgICAgICAgICAgIGMgKz0gMS4wL2xlbmd0aCh2ZWMyKHAueCAvIChjb3MoaS54K3QpL2ludGVuKSxwLnkgLyAoY29zKGkueSt0KS9pbnRlbikpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYyAvPSBmbG9hdChNQVhfSVRFUik7XHJcbiAgICAgICAgYyA9IDEuMTctcG93KGMsIDEuNCk7XHJcbiAgICAgICAgdmVjNCB0ZXggPSB0ZXh0dXJlMkQoQ0NfVGV4dHVyZTAsdXYpO1xyXG4gICAgICAgIHZlYzMgY29sb3VyID0gdmVjMyhwb3coYWJzKGMpLCAyMC4wKSk7XHJcbiAgICAgICAgY29sb3VyID0gY2xhbXAoY29sb3VyICsgdmVjMygwLjAsIDAuMCwgLjApLCAwLjAsIHRleC5hKTtcclxuXHJcbiAgICAgICAgLy8g5re35ZCI5rOi5YWJXHJcbiAgICAgICAgZmxvYXQgYWxwaGEgPSBjKnRleFszXTsgIFxyXG4gICAgICAgIHRleFswXSA9IHRleFswXSArIGNvbG91clswXSphbHBoYTsgXHJcbiAgICAgICAgdGV4WzFdID0gdGV4WzFdICsgY29sb3VyWzFdKmFscGhhOyBcclxuICAgICAgICB0ZXhbMl0gPSB0ZXhbMl0gKyBjb2xvdXJbMl0qYWxwaGE7IFxyXG4gICAgICAgIGZyYWdDb2xvciA9IHZfZnJhZ21lbnRDb2xvciAqIHRleDtcclxuICAgIH1cclxuICAgIHZvaWQgbWFpbigpXHJcbiAgICB7XHJcbiAgICAgICAgbWFpbkltYWdlKGdsX0ZyYWdDb2xvciwgZ2xfRnJhZ0Nvb3JkLnh5KTtcclxuICAgIH1cclxuICAgIGA7XHJcbn1cclxuIl19