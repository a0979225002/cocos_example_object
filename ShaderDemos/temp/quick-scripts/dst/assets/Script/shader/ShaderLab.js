
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Script/shader/ShaderLab.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '60d02YpoG5BlpHIzjewzE0W', 'ShaderLab');
// Script/shader/ShaderLab.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MVP = "\nuniform mat4 viewProj;\nuniform mat4 model;\nattribute vec3 a_position;\nattribute vec2 a_uv0;\nvarying vec2 uv0;\nvoid main () {\n    mat4 mvp;\n    mvp = viewProj * model;\n    vec4 pos = mvp * vec4(a_position, 1);\n    gl_Position = pos;\n    uv0 = a_uv0;\n}\n";
var ShaderLab = {
    GrayScaling: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nvarying vec2 uv0;\nvoid main () {\n    vec4 c = texture2D(texture, uv0);\n    float gray = dot(c.rgb, vec3(0.299 * 0.5, 0.587 * 0.5, 0.114 * 0.5));\n    gl_FragColor = vec4(gray, gray, gray, c.a * 0.5);\n}\n"
    },
    Stone: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nvarying vec2 uv0;\nvoid main () {\n    vec4 c = color * texture2D(texture, uv0);\n    float clrbright = (c.r + c.g + c.b) * (1. / 3.);\n    float gray = (0.6) * clrbright;\n    gl_FragColor = vec4(gray, gray, gray, c.a);\n}\n"
    },
    Ice: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nvarying vec2 uv0;\nvoid main () {\n    vec4 clrx = color * texture2D(texture, uv0);\n    float brightness = (clrx.r + clrx.g + clrx.b) * (1. / 3.);\n\tfloat gray = (1.5)*brightness;\n\tclrx = vec4(gray, gray, gray, clrx.a)*vec4(0.8,1.2,1.5,1);\n    gl_FragColor =clrx;\n}\n"
    },
    Frozen: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nvarying vec2 uv0;\nvoid main () {\n    vec4 c = color * texture2D(texture, uv0);\n    c *= vec4(0.8, 1, 0.8, 1);\n\tc.b += c.a * 0.2;\n    gl_FragColor = c;\n}\n"
    },
    Mirror: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nvarying vec2 uv0;\nvoid main () {\n    vec4 c = color * texture2D(texture, uv0);\n    c.r *= 0.5;\n    c.g *= 0.8;\n    c.b += c.a * 0.2;\n    gl_FragColor = c;\n}\n"
    },
    Poison: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nvarying vec2 uv0;\nvoid main () {\n    vec4 c = color * texture2D(texture, uv0);\n    c.r *= 0.8;\n\tc.r += 0.08 * c.a;\n\tc.g *= 0.8;\n    c.g += 0.2 * c.a;\n\tc.b *= 0.8;\n    gl_FragColor = c;\n}\n"
    },
    Banish: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nvarying vec2 uv0;\nvoid main () {\n    vec4 c = color * texture2D(texture, uv0);\n    float gg = (c.r + c.g + c.b) * (1.0 / 3.0);\n    c.r = gg * 0.9;\n    c.g = gg * 1.2;\n    c.b = gg * 0.8;\n    c.a *= (gg + 0.1);\n    gl_FragColor = c;\n}\n"
    },
    Vanish: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nvarying vec2 uv0;\nvoid main () {\n    vec4 c = color * texture2D(texture, uv0);\n    float gray = (c.r + c.g + c.b) * (1. / 3.);\n    float rgb = gray * 0.8;\n    gl_FragColor = vec4(rgb, rgb, rgb, c.a * (gray + 0.1));\n}\n"
    },
    Invisible: {
        vert: MVP,
        frag: "\nvoid main () {\n    gl_FragColor = vec4(0,0,0,0);\n}\n"
    },
    Blur: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nuniform float num;\nvarying vec2 uv0;\nvoid main () {\n    vec4 sum = vec4(0.0);\n    vec2 size = vec2(num,num);\n    sum += texture2D(texture, uv0 - 0.4 * size) * 0.05;\n\tsum += texture2D(texture, uv0 - 0.3 * size) * 0.09;\n\tsum += texture2D(texture, uv0 - 0.2 * size) * 0.12;\n\tsum += texture2D(texture, uv0 - 0.1 * size) * 0.15;\n\tsum += texture2D(texture, uv0             ) * 0.16;\n\tsum += texture2D(texture, uv0 + 0.1 * size) * 0.15;\n\tsum += texture2D(texture, uv0 + 0.2 * size) * 0.12;\n\tsum += texture2D(texture, uv0 + 0.3 * size) * 0.09;\n    sum += texture2D(texture, uv0 + 0.4 * size) * 0.05;\n    \n    vec4 vectemp = vec4(0,0,0,0);\n    vec4 substract = vec4(0,0,0,0);\n    vectemp = (sum - substract) * color;\n\n    float alpha = texture2D(texture, uv0).a;\n    if(alpha < 0.05) { gl_FragColor = vec4(0 , 0 , 0 , 0); }\n\telse { gl_FragColor = vectemp; }\n}\n"
    },
    GaussBlur: {
        vert: MVP,
        frag: "\n#define repeats 5.\nuniform sampler2D texture;\nuniform vec4 color;\nuniform float num;\nvarying vec2 uv0;\n\nvec4 draw(vec2 uv) {\n    return color * texture2D(texture,uv).rgba; \n}\nfloat grid(float var, float size) {\n    return floor(var*size)/size;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid main()\n{\n    vec4 blurred_image = vec4(0.);\n    for (float i = 0.; i < repeats; i++) { \n        vec2 q = vec2(cos(degrees((i/repeats)*360.)),sin(degrees((i/repeats)*360.))) * (rand(vec2(i,uv0.x+uv0.y))+num); \n        vec2 uv2 = uv0+(q*num);\n        blurred_image += draw(uv2)/2.;\n        q = vec2(cos(degrees((i/repeats)*360.)),sin(degrees((i/repeats)*360.))) * (rand(vec2(i+2.,uv0.x+uv0.y+24.))+num); \n        uv2 = uv0+(q*num);\n        blurred_image += draw(uv2)/2.;\n    }\n    blurred_image /= repeats;\n    gl_FragColor = vec4(blurred_image);\n}\n"
    },
    Dissolve: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nuniform float time;\nvarying vec2 uv0;\n\nvoid main()\n{\n    vec4 c = color * texture2D(texture,uv0);\n    float height = c.r;\n    if(height < time)\n    {\n        discard;\n    }\n    if(height < time+0.04)\n    {\n        // \u6EB6\u89E3\u989C\u8272\uFF0C\u53EF\u4EE5\u81EA\u5B9A\u4E49\n        c = vec4(.9,.6,0.3,c.a);\n    }\n    gl_FragColor = c;\n}\n"
    },
    Fluxay: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nuniform float time;\nvarying vec2 uv0;\n\nvoid main()\n{\n    vec4 src_color = color * texture2D(texture, uv0).rgba;\n\n    float width = 0.08;       //\u6D41\u5149\u7684\u5BBD\u5EA6\u8303\u56F4 (\u8C03\u6574\u8BE5\u503C\u6539\u53D8\u6D41\u5149\u7684\u5BBD\u5EA6)\n    float start = tan(time/1.414);  //\u6D41\u5149\u7684\u8D77\u59CBx\u5750\u6807\n    float strength = 0.008;   //\u6D41\u5149\u589E\u4EAE\u5F3A\u5EA6   (\u8C03\u6574\u8BE5\u503C\u6539\u53D8\u6D41\u5149\u7684\u589E\u4EAE\u5F3A\u5EA6)\n    float offset = 0.5;      //\u504F\u79FB\u503C         (\u8C03\u6574\u8BE5\u503C\u6539\u53D8\u6D41\u5149\u7684\u503E\u659C\u7A0B\u5EA6)\n    if(uv0.x < (start - offset * uv0.y) &&  uv0.x > (start - offset * uv0.y - width))\n    {\n        vec3 improve = strength * vec3(255, 255, 255);\n        vec3 result = improve * vec3( src_color.r, src_color.g, src_color.b);\n        gl_FragColor = vec4(result, src_color.a);\n\n    }else{\n        gl_FragColor = src_color;\n    }\n}\n"
    },
    FluxaySuper: {
        vert: MVP,
        frag: "\n#define TAU 6.12\n#define MAX_ITER 5\nuniform sampler2D texture;\nuniform vec4 color;\nuniform float time;\nvarying vec2 uv0;\n\nvoid main()\n{\n    float time = time * .5+5.;\n    // uv should be the 0-1 uv of texture...\n    vec2 uv = uv0.xy;//fragCoord.xy / iResolution.xy;\n    \n    vec2 p = mod(uv*TAU, TAU)-250.0;\n\n    vec2 i = vec2(p);\n    float c = 1.0;\n    float inten = .0045;\n\n    for (int n = 0; n < MAX_ITER; n++) \n    {\n        float t =  time * (1.0 - (3.5 / float(n+1)));\n        i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(1.5*t + i.x));\n        c += 1.0/length(vec2(p.x / (cos(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n    }\n    c /= float(MAX_ITER);\n    c = 1.17-pow(c, 1.4);\n    vec4 tex = texture2D(texture,uv);\n    vec3 colour = vec3(pow(abs(c), 20.0));\n    colour = clamp(colour + vec3(0.0, 0.0, .0), 0.0, tex.a);\n\n    // \u6DF7\u5408\u6CE2\u5149\n    float alpha = c*tex[3];  \n    tex[0] = tex[0] + colour[0]*alpha; \n    tex[1] = tex[1] + colour[1]*alpha; \n    tex[2] = tex[2] + colour[2]*alpha; \n    gl_FragColor = color * tex;\n}\n"
    },
    Pure: {
        vert: MVP,
        frag: "\nuniform sampler2D texture;\nuniform vec4 color;\nvarying vec2 uv0;\nvoid main () {\n    vec4 c = color * texture2D(texture, uv0);\n    gl_FragColor = vec4(color.rgb, c.a);\n}\n"
    },
    WaterWave: {
        vert: MVP,
        frag: "\n#define F cos(x-y)*cos(y),sin(x+y)*sin(y)\n\nuniform sampler2D texture;\nuniform float time;\nuniform vec3 resolution;\nvarying vec2 uv0;\n\nvec2 s(vec2 p)\n{\n    float d=time*0.2,x=8.*(p.x+d),y=8.*(p.y+d);\n    return vec2(F);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // \u6362\u6210resolution\n    vec2 rs = resolution.xy;\n    // \u6362\u6210\u7EB9\u7406\u5750\u6807v_texCoord.xy\n    vec2 uv = uv0.xy;\n    vec2 q = uv+2./resolution.x*(s(uv)-s(uv+rs));\n    //\u53CD\u8F6Cy\n    // q.y=1.-q.y;\n    fragColor = texture2D(texture,q);\n}\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n"
    }
};
exports.default = ShaderLab;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0XFxzaGFkZXJcXFNoYWRlckxhYi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLElBQU0sR0FBRyxHQUFHLDJRQWFYLENBQUM7QUFFRixJQUFNLFNBQVMsR0FBRztJQUNkLFdBQVcsRUFBRTtRQUNULElBQUksRUFBRSxHQUFHO1FBQ1QsSUFBSSxFQUNaLG9RQVNDO0tBQ0k7SUFDRCxLQUFLLEVBQUU7UUFDSCxJQUFJLEVBQUUsR0FBRztRQUNULElBQUksRUFDWixzUkFVQztLQUNJO0lBQ0QsR0FBRyxFQUFFO1FBQ0QsSUFBSSxFQUFFLEdBQUc7UUFDVCxJQUFJLEVBQ1osc1VBV0M7S0FDSTtJQUNELE1BQU0sRUFBRTtRQUNKLElBQUksRUFBRSxHQUFHO1FBQ1QsSUFBSSxFQUNaLHNOQVVDO0tBQ0k7SUFDRCxNQUFNLEVBQUU7UUFDSixJQUFJLEVBQUUsR0FBRztRQUNULElBQUksRUFDWiwwTkFXQztLQUNJO0lBQ0QsTUFBTSxFQUFFO1FBQ0osSUFBSSxFQUFFLEdBQUc7UUFDVCxJQUFJLEVBQ1osNlBBYUM7S0FDSTtJQUNELE1BQU0sRUFBRTtRQUNKLElBQUksRUFBRSxHQUFHO1FBQ1QsSUFBSSxFQUNaLHlTQWFDO0tBQ0k7SUFDRCxNQUFNLEVBQUU7UUFDSixJQUFJLEVBQUUsR0FBRztRQUNULElBQUksRUFDWixxUkFVQztLQUNJO0lBQ0QsU0FBUyxFQUFFO1FBQ1AsSUFBSSxFQUFFLEdBQUc7UUFDVCxJQUFJLEVBQ1osMERBSUM7S0FDSTtJQUNELElBQUksRUFBRTtRQUNGLElBQUksRUFBRSxHQUFHO1FBQ1QsSUFBSSxFQUNaLHU2QkEwQkM7S0FDSTtJQUNELFNBQVMsRUFBRTtRQUNQLElBQUksRUFBRSxHQUFHO1FBQ1QsSUFBSSxFQUNaLDQ1QkE4QkM7S0FDSTtJQUNELFFBQVEsRUFBRTtRQUNOLElBQUksRUFBRSxHQUFHO1FBQ1QsSUFBSSxFQUNaLDRaQXFCQztLQUNJO0lBQ0QsTUFBTSxFQUFFO1FBQ0osSUFBSSxFQUFFLEdBQUc7UUFDVCxJQUFJLEVBQ1oseWdDQXdCQztLQUNJO0lBQ0QsV0FBVyxFQUFFO1FBQ1QsSUFBSSxFQUFFLEdBQUc7UUFDVCxJQUFJLEVBQ1osNmtDQXVDQztLQUNJO0lBQ0QsSUFBSSxFQUFFO1FBQ0YsSUFBSSxFQUFFLEdBQUc7UUFDVCxJQUFJLEVBQ1osb0xBUUM7S0FDSTtJQUNELFNBQVMsRUFBRTtRQUNQLElBQUksRUFBRSxHQUFHO1FBQ1QsSUFBSSxFQUNaLCtuQkE0QkM7S0FDSTtDQUNKLENBQUM7QUFFRixrQkFBZSxTQUFTLENBQUMiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxuY29uc3QgTVZQID0gYFxyXG51bmlmb3JtIG1hdDQgdmlld1Byb2o7XHJcbnVuaWZvcm0gbWF0NCBtb2RlbDtcclxuYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcclxuYXR0cmlidXRlIHZlYzIgYV91djA7XHJcbnZhcnlpbmcgdmVjMiB1djA7XHJcbnZvaWQgbWFpbiAoKSB7XHJcbiAgICBtYXQ0IG12cDtcclxuICAgIG12cCA9IHZpZXdQcm9qICogbW9kZWw7XHJcbiAgICB2ZWM0IHBvcyA9IG12cCAqIHZlYzQoYV9wb3NpdGlvbiwgMSk7XHJcbiAgICBnbF9Qb3NpdGlvbiA9IHBvcztcclxuICAgIHV2MCA9IGFfdXYwO1xyXG59XHJcbmA7XHJcblxyXG5jb25zdCBTaGFkZXJMYWIgPSB7XHJcbiAgICBHcmF5U2NhbGluZzoge1xyXG4gICAgICAgIHZlcnQ6IE1WUCxcclxuICAgICAgICBmcmFnOiBcclxuYFxyXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xyXG51bmlmb3JtIHZlYzQgY29sb3I7XHJcbnZhcnlpbmcgdmVjMiB1djA7XHJcbnZvaWQgbWFpbiAoKSB7XHJcbiAgICB2ZWM0IGMgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYwKTtcclxuICAgIGZsb2F0IGdyYXkgPSBkb3QoYy5yZ2IsIHZlYzMoMC4yOTkgKiAwLjUsIDAuNTg3ICogMC41LCAwLjExNCAqIDAuNSkpO1xyXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChncmF5LCBncmF5LCBncmF5LCBjLmEgKiAwLjUpO1xyXG59XHJcbmBcclxuICAgIH0sXHJcbiAgICBTdG9uZToge1xyXG4gICAgICAgIHZlcnQ6IE1WUCxcclxuICAgICAgICBmcmFnOiBcclxuYFxyXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xyXG51bmlmb3JtIHZlYzQgY29sb3I7XHJcbnZhcnlpbmcgdmVjMiB1djA7XHJcbnZvaWQgbWFpbiAoKSB7XHJcbiAgICB2ZWM0IGMgPSBjb2xvciAqIHRleHR1cmUyRCh0ZXh0dXJlLCB1djApO1xyXG4gICAgZmxvYXQgY2xyYnJpZ2h0ID0gKGMuciArIGMuZyArIGMuYikgKiAoMS4gLyAzLik7XHJcbiAgICBmbG9hdCBncmF5ID0gKDAuNikgKiBjbHJicmlnaHQ7XHJcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGdyYXksIGdyYXksIGdyYXksIGMuYSk7XHJcbn1cclxuYFxyXG4gICAgfSxcclxuICAgIEljZToge1xyXG4gICAgICAgIHZlcnQ6IE1WUCxcclxuICAgICAgICBmcmFnOiBcclxuYFxyXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xyXG51bmlmb3JtIHZlYzQgY29sb3I7XHJcbnZhcnlpbmcgdmVjMiB1djA7XHJcbnZvaWQgbWFpbiAoKSB7XHJcbiAgICB2ZWM0IGNscnggPSBjb2xvciAqIHRleHR1cmUyRCh0ZXh0dXJlLCB1djApO1xyXG4gICAgZmxvYXQgYnJpZ2h0bmVzcyA9IChjbHJ4LnIgKyBjbHJ4LmcgKyBjbHJ4LmIpICogKDEuIC8gMy4pO1xyXG5cdGZsb2F0IGdyYXkgPSAoMS41KSpicmlnaHRuZXNzO1xyXG5cdGNscnggPSB2ZWM0KGdyYXksIGdyYXksIGdyYXksIGNscnguYSkqdmVjNCgwLjgsMS4yLDEuNSwxKTtcclxuICAgIGdsX0ZyYWdDb2xvciA9Y2xyeDtcclxufVxyXG5gXHJcbiAgICB9LFxyXG4gICAgRnJvemVuOiB7XHJcbiAgICAgICAgdmVydDogTVZQLFxyXG4gICAgICAgIGZyYWc6IFxyXG5gXHJcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XHJcbnVuaWZvcm0gdmVjNCBjb2xvcjtcclxudmFyeWluZyB2ZWMyIHV2MDtcclxudm9pZCBtYWluICgpIHtcclxuICAgIHZlYzQgYyA9IGNvbG9yICogdGV4dHVyZTJEKHRleHR1cmUsIHV2MCk7XHJcbiAgICBjICo9IHZlYzQoMC44LCAxLCAwLjgsIDEpO1xyXG5cdGMuYiArPSBjLmEgKiAwLjI7XHJcbiAgICBnbF9GcmFnQ29sb3IgPSBjO1xyXG59XHJcbmBcclxuICAgIH0sXHJcbiAgICBNaXJyb3I6IHtcclxuICAgICAgICB2ZXJ0OiBNVlAsXHJcbiAgICAgICAgZnJhZzogXHJcbmBcclxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcclxudW5pZm9ybSB2ZWM0IGNvbG9yO1xyXG52YXJ5aW5nIHZlYzIgdXYwO1xyXG52b2lkIG1haW4gKCkge1xyXG4gICAgdmVjNCBjID0gY29sb3IgKiB0ZXh0dXJlMkQodGV4dHVyZSwgdXYwKTtcclxuICAgIGMuciAqPSAwLjU7XHJcbiAgICBjLmcgKj0gMC44O1xyXG4gICAgYy5iICs9IGMuYSAqIDAuMjtcclxuICAgIGdsX0ZyYWdDb2xvciA9IGM7XHJcbn1cclxuYFxyXG4gICAgfSxcclxuICAgIFBvaXNvbjoge1xyXG4gICAgICAgIHZlcnQ6IE1WUCxcclxuICAgICAgICBmcmFnOiBcclxuYFxyXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xyXG51bmlmb3JtIHZlYzQgY29sb3I7XHJcbnZhcnlpbmcgdmVjMiB1djA7XHJcbnZvaWQgbWFpbiAoKSB7XHJcbiAgICB2ZWM0IGMgPSBjb2xvciAqIHRleHR1cmUyRCh0ZXh0dXJlLCB1djApO1xyXG4gICAgYy5yICo9IDAuODtcclxuXHRjLnIgKz0gMC4wOCAqIGMuYTtcclxuXHRjLmcgKj0gMC44O1xyXG4gICAgYy5nICs9IDAuMiAqIGMuYTtcclxuXHRjLmIgKj0gMC44O1xyXG4gICAgZ2xfRnJhZ0NvbG9yID0gYztcclxufVxyXG5gXHJcbiAgICB9LFxyXG4gICAgQmFuaXNoOiB7XHJcbiAgICAgICAgdmVydDogTVZQLFxyXG4gICAgICAgIGZyYWc6IFxyXG5gXHJcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XHJcbnVuaWZvcm0gdmVjNCBjb2xvcjtcclxudmFyeWluZyB2ZWMyIHV2MDtcclxudm9pZCBtYWluICgpIHtcclxuICAgIHZlYzQgYyA9IGNvbG9yICogdGV4dHVyZTJEKHRleHR1cmUsIHV2MCk7XHJcbiAgICBmbG9hdCBnZyA9IChjLnIgKyBjLmcgKyBjLmIpICogKDEuMCAvIDMuMCk7XHJcbiAgICBjLnIgPSBnZyAqIDAuOTtcclxuICAgIGMuZyA9IGdnICogMS4yO1xyXG4gICAgYy5iID0gZ2cgKiAwLjg7XHJcbiAgICBjLmEgKj0gKGdnICsgMC4xKTtcclxuICAgIGdsX0ZyYWdDb2xvciA9IGM7XHJcbn1cclxuYFxyXG4gICAgfSxcclxuICAgIFZhbmlzaDoge1xyXG4gICAgICAgIHZlcnQ6IE1WUCxcclxuICAgICAgICBmcmFnOiBcclxuYFxyXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xyXG51bmlmb3JtIHZlYzQgY29sb3I7XHJcbnZhcnlpbmcgdmVjMiB1djA7XHJcbnZvaWQgbWFpbiAoKSB7XHJcbiAgICB2ZWM0IGMgPSBjb2xvciAqIHRleHR1cmUyRCh0ZXh0dXJlLCB1djApO1xyXG4gICAgZmxvYXQgZ3JheSA9IChjLnIgKyBjLmcgKyBjLmIpICogKDEuIC8gMy4pO1xyXG4gICAgZmxvYXQgcmdiID0gZ3JheSAqIDAuODtcclxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocmdiLCByZ2IsIHJnYiwgYy5hICogKGdyYXkgKyAwLjEpKTtcclxufVxyXG5gXHJcbiAgICB9LFxyXG4gICAgSW52aXNpYmxlOiB7XHJcbiAgICAgICAgdmVydDogTVZQLFxyXG4gICAgICAgIGZyYWc6IFxyXG5gXHJcbnZvaWQgbWFpbiAoKSB7XHJcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAsMCwwLDApO1xyXG59XHJcbmBcclxuICAgIH0sXHJcbiAgICBCbHVyOiB7XHJcbiAgICAgICAgdmVydDogTVZQLFxyXG4gICAgICAgIGZyYWc6IFxyXG5gXHJcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XHJcbnVuaWZvcm0gdmVjNCBjb2xvcjtcclxudW5pZm9ybSBmbG9hdCBudW07XHJcbnZhcnlpbmcgdmVjMiB1djA7XHJcbnZvaWQgbWFpbiAoKSB7XHJcbiAgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcclxuICAgIHZlYzIgc2l6ZSA9IHZlYzIobnVtLG51bSk7XHJcbiAgICBzdW0gKz0gdGV4dHVyZTJEKHRleHR1cmUsIHV2MCAtIDAuNCAqIHNpemUpICogMC4wNTtcclxuXHRzdW0gKz0gdGV4dHVyZTJEKHRleHR1cmUsIHV2MCAtIDAuMyAqIHNpemUpICogMC4wOTtcclxuXHRzdW0gKz0gdGV4dHVyZTJEKHRleHR1cmUsIHV2MCAtIDAuMiAqIHNpemUpICogMC4xMjtcclxuXHRzdW0gKz0gdGV4dHVyZTJEKHRleHR1cmUsIHV2MCAtIDAuMSAqIHNpemUpICogMC4xNTtcclxuXHRzdW0gKz0gdGV4dHVyZTJEKHRleHR1cmUsIHV2MCAgICAgICAgICAgICApICogMC4xNjtcclxuXHRzdW0gKz0gdGV4dHVyZTJEKHRleHR1cmUsIHV2MCArIDAuMSAqIHNpemUpICogMC4xNTtcclxuXHRzdW0gKz0gdGV4dHVyZTJEKHRleHR1cmUsIHV2MCArIDAuMiAqIHNpemUpICogMC4xMjtcclxuXHRzdW0gKz0gdGV4dHVyZTJEKHRleHR1cmUsIHV2MCArIDAuMyAqIHNpemUpICogMC4wOTtcclxuICAgIHN1bSArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYwICsgMC40ICogc2l6ZSkgKiAwLjA1O1xyXG4gICAgXHJcbiAgICB2ZWM0IHZlY3RlbXAgPSB2ZWM0KDAsMCwwLDApO1xyXG4gICAgdmVjNCBzdWJzdHJhY3QgPSB2ZWM0KDAsMCwwLDApO1xyXG4gICAgdmVjdGVtcCA9IChzdW0gLSBzdWJzdHJhY3QpICogY29sb3I7XHJcblxyXG4gICAgZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYwKS5hO1xyXG4gICAgaWYoYWxwaGEgPCAwLjA1KSB7IGdsX0ZyYWdDb2xvciA9IHZlYzQoMCAsIDAgLCAwICwgMCk7IH1cclxuXHRlbHNlIHsgZ2xfRnJhZ0NvbG9yID0gdmVjdGVtcDsgfVxyXG59XHJcbmBcclxuICAgIH0sXHJcbiAgICBHYXVzc0JsdXI6IHtcclxuICAgICAgICB2ZXJ0OiBNVlAsXHJcbiAgICAgICAgZnJhZzogXHJcbmBcclxuI2RlZmluZSByZXBlYXRzIDUuXHJcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XHJcbnVuaWZvcm0gdmVjNCBjb2xvcjtcclxudW5pZm9ybSBmbG9hdCBudW07XHJcbnZhcnlpbmcgdmVjMiB1djA7XHJcblxyXG52ZWM0IGRyYXcodmVjMiB1dikge1xyXG4gICAgcmV0dXJuIGNvbG9yICogdGV4dHVyZTJEKHRleHR1cmUsdXYpLnJnYmE7IFxyXG59XHJcbmZsb2F0IGdyaWQoZmxvYXQgdmFyLCBmbG9hdCBzaXplKSB7XHJcbiAgICByZXR1cm4gZmxvb3IodmFyKnNpemUpL3NpemU7XHJcbn1cclxuZmxvYXQgcmFuZCh2ZWMyIGNvKXtcclxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5ICx2ZWMyKDEyLjk4OTgsNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XHJcbn1cclxudm9pZCBtYWluKClcclxue1xyXG4gICAgdmVjNCBibHVycmVkX2ltYWdlID0gdmVjNCgwLik7XHJcbiAgICBmb3IgKGZsb2F0IGkgPSAwLjsgaSA8IHJlcGVhdHM7IGkrKykgeyBcclxuICAgICAgICB2ZWMyIHEgPSB2ZWMyKGNvcyhkZWdyZWVzKChpL3JlcGVhdHMpKjM2MC4pKSxzaW4oZGVncmVlcygoaS9yZXBlYXRzKSozNjAuKSkpICogKHJhbmQodmVjMihpLHV2MC54K3V2MC55KSkrbnVtKTsgXHJcbiAgICAgICAgdmVjMiB1djIgPSB1djArKHEqbnVtKTtcclxuICAgICAgICBibHVycmVkX2ltYWdlICs9IGRyYXcodXYyKS8yLjtcclxuICAgICAgICBxID0gdmVjMihjb3MoZGVncmVlcygoaS9yZXBlYXRzKSozNjAuKSksc2luKGRlZ3JlZXMoKGkvcmVwZWF0cykqMzYwLikpKSAqIChyYW5kKHZlYzIoaSsyLix1djAueCt1djAueSsyNC4pKStudW0pOyBcclxuICAgICAgICB1djIgPSB1djArKHEqbnVtKTtcclxuICAgICAgICBibHVycmVkX2ltYWdlICs9IGRyYXcodXYyKS8yLjtcclxuICAgIH1cclxuICAgIGJsdXJyZWRfaW1hZ2UgLz0gcmVwZWF0cztcclxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYmx1cnJlZF9pbWFnZSk7XHJcbn1cclxuYFxyXG4gICAgfSxcclxuICAgIERpc3NvbHZlOiB7XHJcbiAgICAgICAgdmVydDogTVZQLFxyXG4gICAgICAgIGZyYWc6IFxyXG5gXHJcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XHJcbnVuaWZvcm0gdmVjNCBjb2xvcjtcclxudW5pZm9ybSBmbG9hdCB0aW1lO1xyXG52YXJ5aW5nIHZlYzIgdXYwO1xyXG5cclxudm9pZCBtYWluKClcclxue1xyXG4gICAgdmVjNCBjID0gY29sb3IgKiB0ZXh0dXJlMkQodGV4dHVyZSx1djApO1xyXG4gICAgZmxvYXQgaGVpZ2h0ID0gYy5yO1xyXG4gICAgaWYoaGVpZ2h0IDwgdGltZSlcclxuICAgIHtcclxuICAgICAgICBkaXNjYXJkO1xyXG4gICAgfVxyXG4gICAgaWYoaGVpZ2h0IDwgdGltZSswLjA0KVxyXG4gICAge1xyXG4gICAgICAgIC8vIOa6tuino+minOiJsu+8jOWPr+S7peiHquWumuS5iVxyXG4gICAgICAgIGMgPSB2ZWM0KC45LC42LDAuMyxjLmEpO1xyXG4gICAgfVxyXG4gICAgZ2xfRnJhZ0NvbG9yID0gYztcclxufVxyXG5gXHJcbiAgICB9LFxyXG4gICAgRmx1eGF5OiB7XHJcbiAgICAgICAgdmVydDogTVZQLFxyXG4gICAgICAgIGZyYWc6IFxyXG5gXHJcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XHJcbnVuaWZvcm0gdmVjNCBjb2xvcjtcclxudW5pZm9ybSBmbG9hdCB0aW1lO1xyXG52YXJ5aW5nIHZlYzIgdXYwO1xyXG5cclxudm9pZCBtYWluKClcclxue1xyXG4gICAgdmVjNCBzcmNfY29sb3IgPSBjb2xvciAqIHRleHR1cmUyRCh0ZXh0dXJlLCB1djApLnJnYmE7XHJcblxyXG4gICAgZmxvYXQgd2lkdGggPSAwLjA4OyAgICAgICAvL+a1geWFieeahOWuveW6puiMg+WbtCAo6LCD5pW06K+l5YC85pS55Y+Y5rWB5YWJ55qE5a695bqmKVxyXG4gICAgZmxvYXQgc3RhcnQgPSB0YW4odGltZS8xLjQxNCk7ICAvL+a1geWFieeahOi1t+Wni3jlnZDmoIdcclxuICAgIGZsb2F0IHN0cmVuZ3RoID0gMC4wMDg7ICAgLy/mtYHlhYnlop7kuq7lvLrluqYgICAo6LCD5pW06K+l5YC85pS55Y+Y5rWB5YWJ55qE5aKe5Lqu5by65bqmKVxyXG4gICAgZmxvYXQgb2Zmc2V0ID0gMC41OyAgICAgIC8v5YGP56e75YC8ICAgICAgICAgKOiwg+aVtOivpeWAvOaUueWPmOa1geWFieeahOWAvuaWnOeoi+W6pilcclxuICAgIGlmKHV2MC54IDwgKHN0YXJ0IC0gb2Zmc2V0ICogdXYwLnkpICYmICB1djAueCA+IChzdGFydCAtIG9mZnNldCAqIHV2MC55IC0gd2lkdGgpKVxyXG4gICAge1xyXG4gICAgICAgIHZlYzMgaW1wcm92ZSA9IHN0cmVuZ3RoICogdmVjMygyNTUsIDI1NSwgMjU1KTtcclxuICAgICAgICB2ZWMzIHJlc3VsdCA9IGltcHJvdmUgKiB2ZWMzKCBzcmNfY29sb3Iuciwgc3JjX2NvbG9yLmcsIHNyY19jb2xvci5iKTtcclxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJlc3VsdCwgc3JjX2NvbG9yLmEpO1xyXG5cclxuICAgIH1lbHNle1xyXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHNyY19jb2xvcjtcclxuICAgIH1cclxufVxyXG5gXHJcbiAgICB9LFxyXG4gICAgRmx1eGF5U3VwZXI6IHtcclxuICAgICAgICB2ZXJ0OiBNVlAsXHJcbiAgICAgICAgZnJhZzogXHJcbmBcclxuI2RlZmluZSBUQVUgNi4xMlxyXG4jZGVmaW5lIE1BWF9JVEVSIDVcclxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcclxudW5pZm9ybSB2ZWM0IGNvbG9yO1xyXG51bmlmb3JtIGZsb2F0IHRpbWU7XHJcbnZhcnlpbmcgdmVjMiB1djA7XHJcblxyXG52b2lkIG1haW4oKVxyXG57XHJcbiAgICBmbG9hdCB0aW1lID0gdGltZSAqIC41KzUuO1xyXG4gICAgLy8gdXYgc2hvdWxkIGJlIHRoZSAwLTEgdXYgb2YgdGV4dHVyZS4uLlxyXG4gICAgdmVjMiB1diA9IHV2MC54eTsvL2ZyYWdDb29yZC54eSAvIGlSZXNvbHV0aW9uLnh5O1xyXG4gICAgXHJcbiAgICB2ZWMyIHAgPSBtb2QodXYqVEFVLCBUQVUpLTI1MC4wO1xyXG5cclxuICAgIHZlYzIgaSA9IHZlYzIocCk7XHJcbiAgICBmbG9hdCBjID0gMS4wO1xyXG4gICAgZmxvYXQgaW50ZW4gPSAuMDA0NTtcclxuXHJcbiAgICBmb3IgKGludCBuID0gMDsgbiA8IE1BWF9JVEVSOyBuKyspIFxyXG4gICAge1xyXG4gICAgICAgIGZsb2F0IHQgPSAgdGltZSAqICgxLjAgLSAoMy41IC8gZmxvYXQobisxKSkpO1xyXG4gICAgICAgIGkgPSBwICsgdmVjMihjb3ModCAtIGkueCkgKyBzaW4odCArIGkueSksIHNpbih0IC0gaS55KSArIGNvcygxLjUqdCArIGkueCkpO1xyXG4gICAgICAgIGMgKz0gMS4wL2xlbmd0aCh2ZWMyKHAueCAvIChjb3MoaS54K3QpL2ludGVuKSxwLnkgLyAoY29zKGkueSt0KS9pbnRlbikpKTtcclxuICAgIH1cclxuICAgIGMgLz0gZmxvYXQoTUFYX0lURVIpO1xyXG4gICAgYyA9IDEuMTctcG93KGMsIDEuNCk7XHJcbiAgICB2ZWM0IHRleCA9IHRleHR1cmUyRCh0ZXh0dXJlLHV2KTtcclxuICAgIHZlYzMgY29sb3VyID0gdmVjMyhwb3coYWJzKGMpLCAyMC4wKSk7XHJcbiAgICBjb2xvdXIgPSBjbGFtcChjb2xvdXIgKyB2ZWMzKDAuMCwgMC4wLCAuMCksIDAuMCwgdGV4LmEpO1xyXG5cclxuICAgIC8vIOa3t+WQiOazouWFiVxyXG4gICAgZmxvYXQgYWxwaGEgPSBjKnRleFszXTsgIFxyXG4gICAgdGV4WzBdID0gdGV4WzBdICsgY29sb3VyWzBdKmFscGhhOyBcclxuICAgIHRleFsxXSA9IHRleFsxXSArIGNvbG91clsxXSphbHBoYTsgXHJcbiAgICB0ZXhbMl0gPSB0ZXhbMl0gKyBjb2xvdXJbMl0qYWxwaGE7IFxyXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiB0ZXg7XHJcbn1cclxuYFxyXG4gICAgfSxcclxuICAgIFB1cmU6IHtcclxuICAgICAgICB2ZXJ0OiBNVlAsXHJcbiAgICAgICAgZnJhZzogXHJcbmBcclxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcclxudW5pZm9ybSB2ZWM0IGNvbG9yO1xyXG52YXJ5aW5nIHZlYzIgdXYwO1xyXG52b2lkIG1haW4gKCkge1xyXG4gICAgdmVjNCBjID0gY29sb3IgKiB0ZXh0dXJlMkQodGV4dHVyZSwgdXYwKTtcclxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiLCBjLmEpO1xyXG59XHJcbmBcclxuICAgIH0sXHJcbiAgICBXYXRlcldhdmU6IHtcclxuICAgICAgICB2ZXJ0OiBNVlAsXHJcbiAgICAgICAgZnJhZzpcclxuYFxyXG4jZGVmaW5lIEYgY29zKHgteSkqY29zKHkpLHNpbih4K3kpKnNpbih5KVxyXG5cclxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcclxudW5pZm9ybSBmbG9hdCB0aW1lO1xyXG51bmlmb3JtIHZlYzMgcmVzb2x1dGlvbjtcclxudmFyeWluZyB2ZWMyIHV2MDtcclxuXHJcbnZlYzIgcyh2ZWMyIHApXHJcbntcclxuICAgIGZsb2F0IGQ9dGltZSowLjIseD04LioocC54K2QpLHk9OC4qKHAueStkKTtcclxuICAgIHJldHVybiB2ZWMyKEYpO1xyXG59XHJcbnZvaWQgbWFpbkltYWdlKCBvdXQgdmVjNCBmcmFnQ29sb3IsIGluIHZlYzIgZnJhZ0Nvb3JkIClcclxue1xyXG4gICAgLy8g5o2i5oiQcmVzb2x1dGlvblxyXG4gICAgdmVjMiBycyA9IHJlc29sdXRpb24ueHk7XHJcbiAgICAvLyDmjaLmiJDnurnnkIblnZDmoId2X3RleENvb3JkLnh5XHJcbiAgICB2ZWMyIHV2ID0gdXYwLnh5O1xyXG4gICAgdmVjMiBxID0gdXYrMi4vcmVzb2x1dGlvbi54KihzKHV2KS1zKHV2K3JzKSk7XHJcbiAgICAvL+WPjei9rHlcclxuICAgIC8vIHEueT0xLi1xLnk7XHJcbiAgICBmcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZSxxKTtcclxufVxyXG52b2lkIG1haW4oKVxyXG57XHJcbiAgICBtYWluSW1hZ2UoZ2xfRnJhZ0NvbG9yLCBnbF9GcmFnQ29vcmQueHkpO1xyXG59XHJcbmBcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNoYWRlckxhYjtcclxuIl19