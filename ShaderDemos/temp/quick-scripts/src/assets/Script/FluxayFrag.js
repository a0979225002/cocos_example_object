"use strict";
cc._RF.push(module, '47640HOQ1ZDg7T5phsuLF1h', 'FluxayFrag');
// Script/FluxayFrag.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Feofox Game
// Author:Lerry
// https://github.com/fylz1125/ShaderDemos
var FluxayFrag = /** @class */ (function () {
    function FluxayFrag() {
    }
    FluxayFrag.fluxay_vert = "\n    attribute vec4 a_position;\n    attribute vec2 a_texCoord;\n    attribute vec4 a_color;\n    varying vec2 v_texCoord;\n    varying vec4 v_fragmentColor;\n    void main()\n    {\n        gl_Position = CC_PMatrix * a_position;\n        v_fragmentColor = a_color;\n        v_texCoord = a_texCoord;\n    }\n    ";
    // 流光特效
    FluxayFrag.fluxay_frag = "\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    varying vec2 v_texCoord;\n    uniform float time;\n    void main()\n    {\n        vec4 src_color = texture2D(CC_Texture0, v_texCoord).rgba;\n\n        float width = 0.02;       //\u6D41\u5149\u7684\u5BBD\u5EA6\u8303\u56F4 (\u8C03\u6574\u8BE5\u503C\u6539\u53D8\u6D41\u5149\u7684\u5BBD\u5EA6)\n        float start = tan(time/1.414);  //\u6D41\u5149\u7684\u8D77\u59CBx\u5750\u6807\n        float strength = 0.006;   //\u6D41\u5149\u589E\u4EAE\u5F3A\u5EA6   (\u8C03\u6574\u8BE5\u503C\u6539\u53D8\u6D41\u5149\u7684\u589E\u4EAE\u5F3A\u5EA6)\n        float offset = 0.5;      //\u504F\u79FB\u503C         (\u8C03\u6574\u8BE5\u503C\u6539\u53D8\u6D41\u5149\u7684\u503E\u659C\u7A0B\u5EA6)\n        if( v_texCoord.x < (start - offset * v_texCoord.y) &&  v_texCoord.x > (start - offset * v_texCoord.y - width))\n        {\n            vec3 improve = strength * vec3(255, 255, 255);\n            vec3 result = improve * vec3( src_color.r, src_color.g, src_color.b);\n            gl_FragColor = vec4(result, src_color.a);\n\n        }else{\n            gl_FragColor = src_color;\n        }\n    }\n    ";
    // 流光的另一种写法
    FluxayFrag.fluxay_frag_s = "\n    #ifdef GL_ES                                 \n    precision mediump float;                          \n    #endif                                          \n    \n    varying vec4 v_fragmentColor;                  \n    varying vec2 v_texCoord;                      \n    \n    // uniform float factor;  \n    // uniform float width;  \n    uniform float time;  \n    // uniform vec3 color; \n    void main()                                      \n    {   \n        float factor = .06;\n        float width = .02;\n        // float offset = .5;\n        vec3 color = vec3(10.,10.,10.);                                           \n        vec4 texColor = texture2D(CC_Texture0, v_texCoord);  \n    \n        float distance = abs(v_texCoord[0]+v_texCoord[1]-tan(time))/1.414;   \n\n        distance = 1.0-(1.0/width)*distance;  \n        distance = max(distance, 0.0);  \n        vec4 sample = vec4(0.0,0.0,0.0,0.0);  \n        sample[0] = color[0] * distance;  \n        sample[1] = color[1] * distance;  \n        sample[2] = color[2] * distance;  \n        sample[3] = distance;  \n\n        float alpha = sample[3]*texColor[3];  \n        texColor[0] = texColor[0] + sample[0]*alpha*factor;  \n        texColor[1] = texColor[1] + sample[1]*alpha*factor;  \n        texColor[2] = texColor[2] + sample[2]*alpha*factor;  \n        gl_FragColor = v_fragmentColor * texColor;  \n    }\n     ";
    // 波光特效
    FluxayFrag.fluxay_frag_super = "\n    #define TAU 6.120470874064187\n    #define MAX_ITER 5\n    uniform float time; \n    varying vec2 v_texCoord;\n    varying vec4 v_fragmentColor;\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n    {\n        float time = time * .5+5.;\n        // uv should be the 0-1 uv of texture...\n        vec2 uv = v_texCoord.xy;//fragCoord.xy / iResolution.xy;\n        \n\n        vec2 p = mod(uv*TAU, TAU)-250.0;\n\n        vec2 i = vec2(p);\n        float c = 1.0;\n        float inten = .0045;\n\n        for (int n = 0; n < MAX_ITER; n++) \n        {\n            float t =  time * (1.0 - (3.5 / float(n+1)));\n            i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(1.5*t + i.x));\n            c += 1.0/length(vec2(p.x / (cos(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n        }\n        c /= float(MAX_ITER);\n        c = 1.17-pow(c, 1.4);\n        vec4 tex = texture2D(CC_Texture0,uv);\n        vec3 colour = vec3(pow(abs(c), 20.0));\n        colour = clamp(colour + vec3(0.0, 0.0, .0), 0.0, tex.a);\n\n        // \u6DF7\u5408\u6CE2\u5149\n        float alpha = c*tex[3];  \n        tex[0] = tex[0] + colour[0]*alpha; \n        tex[1] = tex[1] + colour[1]*alpha; \n        tex[2] = tex[2] + colour[2]*alpha; \n        fragColor = v_fragmentColor * tex;\n    }\n    void main()\n    {\n        mainImage(gl_FragColor, gl_FragCoord.xy);\n    }\n    ";
    return FluxayFrag;
}());
exports.default = FluxayFrag;

cc._RF.pop();