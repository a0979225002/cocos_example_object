{"version":3,"sources":["assets\\Script\\TurnPageFrag.ts"],"names":[],"mappings":";;;;;;AAAA;IAAA;IAwPA,CAAC;IAvPU,0BAAa,GAAG,2TAYtB,CAAC;IACK,0BAAa,GAAG,y3SAyOtB,CAAC;IACN,mBAAC;CAxPD,AAwPC,IAAA;kBAxPoB,YAAY","file":"","sourceRoot":"/","sourcesContent":["export default class TurnPageFrag{\r\n    static turnpage_vert = `\r\n    attribute vec4 a_position;\r\n    attribute vec2 a_texCoord;\r\n    attribute vec4 a_color;\r\n    varying vec2 v_texCoord;\r\n    varying vec4 v_fragmentColor;\r\n    void main()\r\n    {\r\n        gl_Position = CC_PMatrix * a_position;\r\n        v_fragmentColor = a_color;\r\n        v_texCoord = a_texCoord;\r\n    }\r\n    `;\r\n    static turnpage_frag = `\r\n    uniform vec2 resolution;\r\n    uniform vec2 mouse;\r\n    varying vec2 v_texCoord;\r\n\r\n    const float pi = 3.14159;\r\n    const float twopi = 6.28319;\r\n\r\n    const float e0 = 0.018;\r\n    const float ppow = 2.0;\r\n\r\n    const float bcolorMix = 0.67;\r\n    const float maxBcolVal = 0.4;\r\n\r\n    const float diffint = 1.2;\r\n    const float ambientt = 0.1;\r\n    const float ambientb = 0.4;\r\n\r\n    const vec2 specpos = vec2(0.85, -0.2);\r\n    const float specpow = 5.;\r\n    const float specwidth = 0.4;\r\n    const float specint = 0.6;\r\n\r\n    const vec2 shadowoffset = vec2(0.07, -0.04);\r\n    const float shadowsmoothness = 0.012;\r\n    const float shadowint = 0.25;\r\n\r\n    const float aawidth = 0.7;\r\n    const int aasamples = 3;\r\n\r\n    const bool showpoints = false;\r\n    const bool colors = false;\r\n    const bool anim = true;\r\n\r\n    // #define swap_x\r\n    // Simple \"random\" function\r\n    float random(float co)\r\n    {\r\n        return fract(sin(co*12.989) * 43758.545);\r\n    }\r\n\r\n    vec4 getPagebackColor()\r\n    {\r\n        \r\n        float cn = 1.;\r\n        vec4 pagebackColor;\r\n        pagebackColor.r = maxBcolVal*random(cn + 263.714);\r\n        pagebackColor.g = maxBcolVal*random(cn*4. - 151.894);\r\n        pagebackColor.b = maxBcolVal*random(cn*7. + 87.548);\r\n        pagebackColor.a = 1.0;\r\n        return pagebackColor;\r\n    }\r\n\r\n    vec2 rotateVec(vec2 vect, float angle)\r\n    {\r\n        float xr = vect.x*cos(angle) + vect.y*sin(angle);\r\n        float yr = vect.x*sin(angle) - vect.y*cos(angle);\r\n        return vec2(xr, yr);\r\n    }\r\n\r\n    // Curl function on the axis bottom left corner - corner of the sheet\r\n    float pageFunction(float x, float e)\r\n    {\r\n        return pow(pow(x, ppow) - e, 1./ppow);\r\n    }\r\n\r\n    // Derivate of the curl function for light calculations\r\n    float pageFunctionDer(float x, float e)\r\n    {\r\n        return pow(x, ppow - 1.)/pow(pow(x, ppow) - e, (ppow - 1.)/ppow);\r\n    }\r\n\r\n    vec4 turnPage(vec2 fragCoord)\r\n    {\r\n        // General calculations\r\n        vec2 uv = v_texCoord.xy ;//fragCoord.xy / resolution.yy;\r\n        float ratio = resolution.x/resolution.y;\r\n        \r\n        // As long as one doesn't click on the canvas, the animation runs\r\n        vec2 mpoint;\r\n        bool firstcycle;\r\n        \r\n        vec2 Mouse2 = mouse;\r\n        #ifdef swap_x\r\n        Mouse2.x = resolution.x - Mouse2.x;\r\n        #endif\r\n        mpoint = Mouse2.xy;\r\n        firstcycle = true;\r\n        vec2 midmpoint = mpoint*0.5;\r\n        float mdist = distance(fragCoord, mpoint);\r\n        float e = e0*pow(mdist/resolution.y, 2.) + 0.02*e0*smoothstep(0., 0.12, mdist/resolution.y);\r\n        float angle = - atan(mpoint.x/mpoint.y) + pi*0.5;\r\n        \r\n        vec2 uv2 = uv;\r\n        #ifdef swap_x\r\n        uv2.x = ratio - uv2.x;\r\n        #endif\r\n        \r\n        vec2 uvr = rotateVec(uv2 - midmpoint/resolution.yy, angle);\r\n        \r\n        float pagefunc = pageFunction(uvr.x, e);\r\n        vec2 uvr2 = vec2(pagefunc, uvr.y); \r\n        vec2 uvr3 = rotateVec(uvr2, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\r\n        \r\n        vec2 uvr2b = vec2(-pagefunc, uvr.y); \r\n        vec2 uvr3b = rotateVec(uvr2b, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\r\n        \r\n        #ifdef swap_x\r\n        uvr3b.x = ratio - uvr3b.x;\r\n        #endif\r\n            \r\n        vec4 i; \r\n        // Turned page\r\n        if (uvr.x>0. && uvr3b.y>0.)\r\n        {\r\n            vec2 uvcorr = vec2(ratio, 1.);\r\n            vec2 uvrcorr = rotateVec(uvcorr - midmpoint/resolution.yy, angle);\r\n            float pagefunccorr = pageFunction(uvrcorr.x, e);\r\n            vec2 uvrcorr2 = vec2(-pagefunccorr, uvrcorr.y); \r\n            vec2 uvrcorr3 = rotateVec(uvrcorr2, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\r\n        \r\n            float pagefuncder = pageFunctionDer(uvr.x, e);\r\n            float intfac = 1. - diffint*(1. - 1./pagefuncder);\r\n\r\n            if(uvr3.x>=0. || uvr3.y<=0.)\r\n            {\r\n                // Top of the turned page           \r\n                float mdists = distance(fragCoord, mpoint)*0.7 - 55.;\r\n                float es = e0*pow(mdists/resolution.y, 2.) + 0.02*e0*smoothstep(0., 0.08, mdist/resolution.y);\r\n                vec2 uvrs = rotateVec(uv2 - midmpoint/resolution.yy - shadowoffset, angle);\r\n                float pagefuncs = pageFunction(uvrs.x + 0.015, es - 0.001);\r\n                vec2 uvr2s = vec2(pagefuncs, uvrs.y); \r\n                vec2 uvr3s = rotateVec(uvr2s, -angle) - vec2(1., -1.)*midmpoint/resolution.yy;\r\n                float shadow = 1. - (1. - smoothstep(-shadowsmoothness, shadowsmoothness, uvr3s.x))*(1. - smoothstep(shadowsmoothness, -shadowsmoothness, uvr3s.y));\r\n                \r\n                float difft = intfac*(1. - ambientt) + ambientt;\r\n                difft = difft*(shadow*shadowint + 1. - shadowint)/2. + mix(1. - shadowint, difft, shadow)/2.;\r\n                if (firstcycle)\r\n                    i = difft*(colors?vec4(1., 0.3, 0.3, 1.):texture2D(CC_Texture0, mod((uvr3b - uvrcorr3)/vec2(-ratio, 1.), 1.)));\r\n                else\r\n                    i = difft*(colors?vec4(1., 0.3, 0.3, 1.):texture2D(CC_Texture0, mod((uvr3b - uvrcorr3)/vec2(-ratio, 1.), 1.)));\r\n            }\r\n            else\r\n            {\r\n                // Bottom of the turned page\r\n                float diffb = intfac*(1. - ambientb) + ambientb;\r\n                float spec = pow(smoothstep(specpos.x - 0.35, specpos.x, intfac)*smoothstep(specpos.x + 0.35, specpos.x, intfac), specpow);\r\n                spec*= specint*pow(1. - pow(clamp(abs(uvr.y - specpos.y), 0., specwidth*2.), 2.)/specwidth, specpow);\r\n                if (firstcycle)\r\n                    i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(texture2D(CC_Texture0, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), getPagebackColor(), bcolorMix));\r\n                else\r\n                    i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(texture2D(CC_Texture0, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), getPagebackColor(), bcolorMix));\r\n                //i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):texture2D(iChannel1, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), vec4(0.3, 0., 0., 1.));\r\n                i = mix(i, vec4(1.0), spec);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // \"Background\" with simple shadow\r\n            vec2 mpointbg = vec2(0.2, 0.01);\r\n            vec2 midmpointbg = mpointbg*0.5;\r\n            float mdistbg = distance(fragCoord, mpointbg);\r\n            float ebg = e0*pow(mdistbg/resolution.y, 2.) + 0.01*e0*smoothstep(0., 0.12, mdistbg/resolution.y);\r\n            float anglebg = 0.001; //- atan(mpointbg.x/mpointbg.y) + pi*0.5;\r\n            vec2 uvrbg = rotateVec(uv - midmpointbg/resolution.yy, anglebg);\r\n            //float pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), clamp(uvrbg.x*5., 0., 1.));\r\n            float pagefuncbg;\r\n            if (uvrbg.x<0.15)\r\n            pagefuncbg = uvrbg.x;\r\n            else\r\n            pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), smoothstep(mpoint.x/resolution.x + 0.1, mpoint.x/resolution.x, uvrbg.x));\r\n            \r\n            vec2 uvr2bbg = vec2(-pagefuncbg, uvrbg.y); \r\n            vec2 uvr3bbg = rotateVec(uvr2bbg, -anglebg) - vec2(1., -1.)*midmpointbg/resolution.yy;\r\n            vec2 uvcorrbg = vec2(ratio, 1.);\r\n            vec2 uvrcorrbg = rotateVec(uvcorrbg - midmpointbg/resolution.yy, anglebg);\r\n            float pagefunccorrbg = pageFunction(uvrcorrbg.x, ebg);\r\n            vec2 uvrcorr2bg = vec2(-pagefunccorrbg, uvrcorrbg.y); \r\n            vec2 uvrcorr3bg = rotateVec(uvrcorr2bg, -anglebg) - vec2(1., -1.)*midmpointbg/resolution.yy;       \r\n            float pagefuncderbg = pageFunctionDer(uvrbg.x, ebg);\r\n            float intfacbg = 1. - diffint*(1. - 1./pagefuncderbg);\r\n            float difftbg = intfacbg*(1. - ambientt) + ambientt;\r\n            \r\n            if (firstcycle) \r\n                i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture2D(CC_Texture0, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\r\n            else\r\n                i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture2D(CC_Texture0, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\r\n            float bgshadow = 1. + shadowint*smoothstep(-0.08+shadowsmoothness*4., -0.08, uvr3b.y) - shadowint;\r\n            \r\n            if (uvr3b.y<0.)\r\n            i*= bgshadow;\r\n        }\r\n        return i;\r\n    }\r\n    \r\n    void mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n    {\r\n        // Antialiasing\r\n        vec4 vs = vec4(0.);\r\n        for (int j=0;j<aasamples ;j++)\r\n        {\r\n        float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\r\n        for (int i=0;i<aasamples ;i++)\r\n        {\r\n            float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\r\n            vs+= turnPage(fragCoord + vec2(ox, oy));\r\n        }\r\n        }\r\n        vec4 i = vs/vec4(aasamples*aasamples);    \r\n        \r\n        // Show the mouse points. Was only used for development\r\n        vec4 ocol; \r\n        if (showpoints)\r\n        {\r\n            float ratio = resolution.x/resolution.y;\r\n            vec2 mpoint = mouse.xy;\r\n            vec2 midmpoint = mouse.xy*0.5;\r\n            float mdist = distance(fragCoord, mpoint);\r\n            float midmdist = distance(fragCoord, midmpoint);\r\n            \r\n            ocol = mix(i, vec4(1., 0., 0., 1.), smoothstep(6., 4., mdist));\r\n            ocol = mix(ocol, vec4(1., 1., 0., 1.), smoothstep(6., 4., midmdist));\r\n        }\r\n        else\r\n            ocol = i;\r\n            \r\n        fragColor = ocol;\r\n    }\r\n\r\n    void main()\r\n    {\r\n        mainImage(gl_FragColor, gl_FragCoord.xy);\r\n    }\r\n    `;\r\n}"]}