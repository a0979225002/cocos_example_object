{
  "ver": "1.0.22",
  "uuid": "a63d21a2-5580-4912-bfba-ddf40b5831c6",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\n\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n\n  pos = cc_matViewProj * pos;\n\n  v_uv0 = a_uv0;\n  v_color = a_color;\n\n  gl_Position = pos;\n}\n",
        "frag": "\nprecision highp float;\n\nvarying vec2 v_uv0;\n\nuniform float time;\nvec3 sphere = vec3(0, 0, 2);\nfloat sphere_size = 1.3;\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n  \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                  mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n              mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                  mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n  radius = radius * radius;\n  float dt = dot(rdir, sp - rpos);\n  if (dt < 0.0) {\n    return -1.0;\n  }\n  vec3 tmp = rpos - sp;\n  tmp.x = dot(tmp, tmp);\n  tmp.x = tmp.x - dt*dt;\n  if (tmp.x >= radius) {\n    return -1.0;\n  }\n  dt = dt - sqrt(radius - tmp.x);\n  point = rpos + rdir * dt;\n  normal = normalize(point - sp);\n  return dt;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvoid main () {\n  vec3 point; \n  vec3 normal;\n  vec2 uv = v_uv0.xy * 2.0 - 1.0;\n  uv.y = -uv.y;\n  vec3 ray = vec3(uv.x, uv.y, 1.0);\n  ray = normalize(ray);\n\n  vec3 c = vec3( 0. );\n  for( float i = 0.; i < 30.; i++ ) {\n    float dist = raySphere(vec3(0.0), ray, sphere, sphere_size - .01 * i, point, normal);\n    \n    if (dist > 0.0) {\n          float f = 0.;\n          vec3 pos = 2. / ( .5 * i + 1. ) * point + .1 * time;\n          vec3 q = 8.0*pos;\n          f  = 0.5000*noise( q ); q = m*q*2.01;\n          f += 0.2500*noise( q ); q = m*q*2.02;\n          f += 0.1250*noise( q ); q = m*q*2.03;\n          f += 0.0625*noise( q ); q = m*q*2.01;\n          f *= dot( normal, vec3( 0., 0., 1. ) );\n          c += vec3( f * f  );\n      } \n    }\n  \n  vec3 col = smoothstep( 0., 1., c / 10. );\n  gl_FragColor = vec4(col, col.x);\n}\n"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n\nin vec2 a_uv0;\nout vec2 v_uv0;\n\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n\n  pos = cc_matViewProj * pos;\n\n  v_uv0 = a_uv0;\n  v_color = a_color;\n\n  gl_Position = pos;\n}\n",
        "frag": "\nprecision highp float;\n\nin vec2 v_uv0;\n\nuniform TIME {\n  float time;\n}\n\nvec3 sphere = vec3(0, 0, 2);\nfloat sphere_size = 1.3;\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n  \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                  mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n              mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                  mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n  radius = radius * radius;\n  float dt = dot(rdir, sp - rpos);\n  if (dt < 0.0) {\n    return -1.0;\n  }\n  vec3 tmp = rpos - sp;\n  tmp.x = dot(tmp, tmp);\n  tmp.x = tmp.x - dt*dt;\n  if (tmp.x >= radius) {\n    return -1.0;\n  }\n  dt = dt - sqrt(radius - tmp.x);\n  point = rpos + rdir * dt;\n  normal = normalize(point - sp);\n  return dt;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvoid main () {\n  vec3 point; \n  vec3 normal;\n  vec2 uv = v_uv0.xy * 2.0 - 1.0;\n  uv.y = -uv.y;\n  vec3 ray = vec3(uv.x, uv.y, 1.0);\n  ray = normalize(ray);\n\n  vec3 c = vec3( 0. );\n  for( float i = 0.; i < 30.; i++ ) {\n    float dist = raySphere(vec3(0.0), ray, sphere, sphere_size - .01 * i, point, normal);\n    \n    if (dist > 0.0) {\n          float f = 0.;\n          vec3 pos = 2. / ( .5 * i + 1. ) * point + .1 * time;\n          vec3 q = 8.0*pos;\n          f  = 0.5000*noise( q ); q = m*q*2.01;\n          f += 0.2500*noise( q ); q = m*q*2.02;\n          f += 0.1250*noise( q ); q = m*q*2.03;\n          f += 0.0625*noise( q ); q = m*q*2.01;\n          f *= dot( normal, vec3( 0., 0., 1. ) );\n          c += vec3( f * f  );\n      } \n    }\n  \n  vec3 col = smoothstep( 0., 1., c / 10. );\n  gl_FragColor = vec4(col, col.x);\n}\n"
      }
    }
  ],
  "subMetas": {}
}