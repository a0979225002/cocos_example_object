{
  "ver": "1.0.22",
  "uuid": "f881dd49-a3ab-4e20-95a5-8c8d05816286",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\n\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * pos;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n\n  gl_Position = pos;\n}\n",
        "frag": "\nprecision highp float;\n\nconst float cloudscale = 1.1;\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n  const float K1 = 0.366025404;\n\n  const float K2 = 0.211324865;\n\n  vec2 i = floor(p + (p.x+p.y)*K1);  \n  vec2 a = p - i + (i.x+i.y)*K2;\n  vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\n  vec2 b = a - o + K2;\n  vec2 c = a - 1.0 + 2.0*K2;\n  vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n  vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n  return dot(n, vec3(70.0));  \n}\n\nfloat fbm(vec2 n) {\n  float total = 0.0, amplitude = 0.1;\n  for (int i = 0; i < 7; i++) {\n    total += noise(n) * amplitude;\n    n = m * n;\n    amplitude *= 0.4;\n  }\n  return total;\n}\n\nvarying vec4 v_color;\nvarying vec2 v_uv0;\n\nuniform sampler2D texture;\n\nuniform vec2 resolution;\nuniform float time;\nvoid main() {\n    vec2 p = v_uv0.xy;\n    vec2 uv = p*vec2(resolution.x / resolution.y, 1.0);\n    float t = time * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n\n    float r = 0.0;\n    uv *= cloudscale;\n    uv -= q - t;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n      r += abs(weight*noise( uv ));\n      uv = m*uv + t;\n      weight *= 0.7;\n    }\n\n    float f = 0.0;\n    uv = p*vec2(resolution.x/resolution.y,1.0);\n    uv *= cloudscale;\n    uv -= q - t;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n      f += weight*noise( uv );\n      uv = m*uv + t;\n      weight *= 0.6;\n    }\n    \n    f *= r + f;\n\n    float c = 0.0;\n    t = time * speed * 2.0;\n    uv = p*vec2(resolution.x/resolution.y,1.0);\n    uv *= cloudscale*2.0;\n    uv -= q - t;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n      c += weight*noise( uv );\n      uv = m*uv + t;\n      weight *= 0.6;\n    }\n\n    float c1 = 0.0;\n    t = time * speed * 3.0;\n    uv = p*vec2(resolution.x/resolution.y,1.0);\n    uv *= cloudscale*3.0;\n    uv -= q - t;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n      c1 += abs(weight*noise( uv ));\n      uv = m*uv + t;\n      weight *= 0.6;\n    }\n  \n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n  \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n    gl_FragColor = vec4( result, 1.0 );\n}\n"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n\nin vec2 a_uv0;\nout vec2 v_uv0;\n\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * pos;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n\n  gl_Position = pos;\n}\n",
        "frag": "\nprecision highp float;\n\nconst float cloudscale = 1.1;\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n  const float K1 = 0.366025404;\n\n  const float K2 = 0.211324865;\n\n  vec2 i = floor(p + (p.x+p.y)*K1);  \n  vec2 a = p - i + (i.x+i.y)*K2;\n  vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\n  vec2 b = a - o + K2;\n  vec2 c = a - 1.0 + 2.0*K2;\n  vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n  vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n  return dot(n, vec3(70.0));  \n}\n\nfloat fbm(vec2 n) {\n  float total = 0.0, amplitude = 0.1;\n  for (int i = 0; i < 7; i++) {\n    total += noise(n) * amplitude;\n    n = m * n;\n    amplitude *= 0.4;\n  }\n  return total;\n}\n\nin vec4 v_color;\nin vec2 v_uv0;\n\nuniform sampler2D texture;\n\nuniform CLOUD {\n  vec2 resolution;\n  float time;\n}\n\nvoid main() {\n    vec2 p = v_uv0.xy;\n    vec2 uv = p*vec2(resolution.x / resolution.y, 1.0);\n    float t = time * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n\n    float r = 0.0;\n    uv *= cloudscale;\n    uv -= q - t;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n      r += abs(weight*noise( uv ));\n      uv = m*uv + t;\n      weight *= 0.7;\n    }\n\n    float f = 0.0;\n    uv = p*vec2(resolution.x/resolution.y,1.0);\n    uv *= cloudscale;\n    uv -= q - t;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n      f += weight*noise( uv );\n      uv = m*uv + t;\n      weight *= 0.6;\n    }\n    \n    f *= r + f;\n\n    float c = 0.0;\n    t = time * speed * 2.0;\n    uv = p*vec2(resolution.x/resolution.y,1.0);\n    uv *= cloudscale*2.0;\n    uv -= q - t;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n      c += weight*noise( uv );\n      uv = m*uv + t;\n      weight *= 0.6;\n    }\n\n    float c1 = 0.0;\n    t = time * speed * 3.0;\n    uv = p*vec2(resolution.x/resolution.y,1.0);\n    uv *= cloudscale*3.0;\n    uv -= q - t;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n      c1 += abs(weight*noise( uv ));\n      uv = m*uv + t;\n      weight *= 0.6;\n    }\n  \n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n  \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n    gl_FragColor = vec4( result, 1.0 );\n}\n"
      }
    }
  ],
  "subMetas": {}
}