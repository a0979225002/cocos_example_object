{
  "ver": "1.0.25",
  "uuid": "1b11cb31-9016-4fb7-b57e-e2a77d6e9d7b",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\n#if USE_TEXTURE\n    attribute vec2 a_uv0;\n    varying vec2 v_uv0;\n#endif\nattribute vec4 a_color;\nvarying vec4 v_color;\nvoid main () {\n    mat4 mvp;\n    #if CC_USE_MODEL\n        mvp = cc_matViewProj * cc_matWorld;\n    #else\n        mvp = cc_matViewProj;\n    #endif\n    #if USE_TEXTURE\n        v_uv0 = a_uv0;\n    #endif\n    #if USE_TINT\n    #endif\n    v_color = a_color;\n    gl_Position = mvp * vec4(a_position, 1);\n}",
        "frag": "\n  precision highp float;\n  #if USE_TEXTURE\n      varying vec2 v_uv0;\n      uniform sampler2D texture;\n  #endif\n  varying vec4 v_color;\n  uniform float Size;\nuniform float Scale;\nuniform float Edge;\n  vec2 c_UV0_main_5() {\n    return v_uv0;\n}\nvec4 c_TextureToRGBA_main_3(vec2 UV, sampler2D Texture) {\n    return texture2D(Texture, UV);\n}\nvec2 c_1To2_main_32(float Input) {\n    return vec2(Input);\n}\nvec2 c_UVTilingAndOffset_main_30(vec2 UV, vec2 Tiling, vec2 Offset) {\n    return UV * Tiling + Offset;\n}\nfloat c_NoiseSimple_f_noise_randomValue_4(vec2 UV) {\n    return fract(sin(dot(UV, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat c_NoiseSimple_f_noise_interpolate_4(float a, float b, float t) {\n    return (1.0 - t) * a + (t * b);\n }\nfloat c_NoiseSimple_f_value_noise_4(vec2 UV) {\nvec2 i = floor(UV);\nvec2 f = fract(UV);\nf = f * f * (3.0 - 2.0 * f);\nUV = abs(fract(UV) - 0.5);\nvec2 c0 = i + vec2(0.0, 0.0);\nvec2 c1 = i + vec2(1.0, 0.0);\nvec2 c2 = i + vec2(0.0, 1.0);\nvec2 c3 = i + vec2(1.0, 1.0);\nfloat r0 = c_NoiseSimple_f_noise_randomValue_4(c0);\nfloat r1 = c_NoiseSimple_f_noise_randomValue_4(c1);\nfloat r2 = c_NoiseSimple_f_noise_randomValue_4(c2);\nfloat r3 = c_NoiseSimple_f_noise_randomValue_4(c3);\nfloat bottomOfGrid = c_NoiseSimple_f_noise_interpolate_4(r0, r1, f.x);\nfloat topOfGrid = c_NoiseSimple_f_noise_interpolate_4(r2, r3, f.x);\nfloat t = c_NoiseSimple_f_noise_interpolate_4(bottomOfGrid, topOfGrid, f.y);\nreturn t;\n }\nfloat c_NoiseSimple_main_4(vec2 UV, float Scale) {\n   float t = 0.0;\n   float freq = pow(2.0, 0.0);\n   float amp = pow(0.5, 3.0);\n   t += c_NoiseSimple_f_value_noise_4(vec2(UV.x * Scale / freq, UV.y * Scale / freq)) * amp;\n   freq = pow(2.0, 1.0);\n   amp = pow(0.5, 2.0);\n   t += c_NoiseSimple_f_value_noise_4(vec2(UV.x * Scale / freq, UV.y * Scale / freq)) * amp;\n   freq = pow(2.0, 2.0);\n   amp = pow(0.5, 1.0);\n   t += c_NoiseSimple_f_value_noise_4(vec2(UV.x * Scale / freq, UV.y * Scale / freq)) * amp;\n   return t;\n}\nfloat c_Step1_main_7(float Input, float Edge) {\n    return step(Edge, Input);\n}\nfloat c_Mul1_main_9(float InputA, float InputB) {\n    return (InputA * InputB);\n}\nvec4 c_1To4_main_11(float Input) {\n    return vec4(Input);\n}\nvec4 c_Mul4_main_12(vec4 InputA, vec4 InputB) {\n    return (InputA * InputB);\n}\nfloat c_Complement1_main_13(float Input) {\n    return (1.0 - Input);\n}\nfloat c_Mul1_main_14(float InputA, float InputB) {\n    return (InputA * InputB);\n}\nvec4 c_1To4_main_19(float Input) {\n    return vec4(Input);\n}\nvec4 c_Add4_main_20(vec4 InputA, vec4 InputB) {\n    return (InputA + InputB);\n}\nvec4 c_Output_main_1(vec4 Color) {\n    return Color;\n}\nvoid main()\n{\n    vec2 out_UV_UV0_5 = c_UV0_main_5();\n    vec4 out_Color_TextureToRGBA_3 = c_TextureToRGBA_main_3(out_UV_UV0_5, texture);\n    float out_a_TextureToRGBA_3 = out_Color_TextureToRGBA_3.a;\n    vec2 out_Output_1To2_32 = c_1To2_main_32(Scale);\n    vec2 out_UV_UVTilingAndOffset_30 = c_UVTilingAndOffset_main_30(out_UV_UV0_5, out_Output_1To2_32, v_uv0);\n    float out_Output_NoiseSimple_4 = c_NoiseSimple_main_4(out_UV_UVTilingAndOffset_30, Size);\n    float out_Output_Step1_7 = c_Step1_main_7(out_Output_NoiseSimple_4, Edge);\n    float out_Output_Mul1_9 = c_Mul1_main_9(out_Output_Step1_7, out_a_TextureToRGBA_3);\n    vec4 out_Output_1To4_11 = c_1To4_main_11(out_Output_Mul1_9);\n    vec4 out_Output_Mul4_12 = c_Mul4_main_12(out_Color_TextureToRGBA_3, out_Output_1To4_11);\n    float out_Output_Complement1_13 = c_Complement1_main_13(out_Output_Mul1_9);\n    float out_Output_Mul1_14 = c_Mul1_main_14(out_a_TextureToRGBA_3, out_Output_Complement1_13);\n    vec4 out_Output_1To4_19 = c_1To4_main_19(out_Output_Mul1_14);\n    vec4 out_Output_Add4_20 = c_Add4_main_20(out_Output_Mul4_12, out_Output_1To4_19);\n    gl_FragColor = c_Output_main_1(out_Output_Add4_20);\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\n#if USE_TEXTURE\n    in vec2 a_uv0;\n    out vec2 v_uv0;\n#endif\nin vec4 a_color;\nout vec4 v_color;\nvoid main () {\n    mat4 mvp;\n    #if CC_USE_MODEL\n        mvp = cc_matViewProj * cc_matWorld;\n    #else\n        mvp = cc_matViewProj;\n    #endif\n    #if USE_TEXTURE\n        v_uv0 = a_uv0;\n    #endif\n    #if USE_TINT\n    #endif\n    v_color = a_color;\n    gl_Position = mvp * vec4(a_position, 1);\n}",
        "frag": "\n  precision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n  #if USE_TEXTURE\n      in vec2 v_uv0;\n      uniform sampler2D texture;\n  #endif\n  in vec4 v_color;\n  uniform Constant {\n  float Size;\n  float Scale;\n  float Edge;\n};\n  vec2 c_UV0_main_5() {\n    return v_uv0;\n}\nvec4 c_TextureToRGBA_main_3(vec2 UV, sampler2D Texture) {\n    return texture2D(Texture, UV);\n}\nvec2 c_1To2_main_32(float Input) {\n    return vec2(Input);\n}\nvec2 c_UVTilingAndOffset_main_30(vec2 UV, vec2 Tiling, vec2 Offset) {\n    return UV * Tiling + Offset;\n}\nfloat c_NoiseSimple_f_noise_randomValue_4(vec2 UV) {\n    return fract(sin(dot(UV, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat c_NoiseSimple_f_noise_interpolate_4(float a, float b, float t) {\n    return (1.0 - t) * a + (t * b);\n }\nfloat c_NoiseSimple_f_value_noise_4(vec2 UV) {\nvec2 i = floor(UV);\nvec2 f = fract(UV);\nf = f * f * (3.0 - 2.0 * f);\nUV = abs(fract(UV) - 0.5);\nvec2 c0 = i + vec2(0.0, 0.0);\nvec2 c1 = i + vec2(1.0, 0.0);\nvec2 c2 = i + vec2(0.0, 1.0);\nvec2 c3 = i + vec2(1.0, 1.0);\nfloat r0 = c_NoiseSimple_f_noise_randomValue_4(c0);\nfloat r1 = c_NoiseSimple_f_noise_randomValue_4(c1);\nfloat r2 = c_NoiseSimple_f_noise_randomValue_4(c2);\nfloat r3 = c_NoiseSimple_f_noise_randomValue_4(c3);\nfloat bottomOfGrid = c_NoiseSimple_f_noise_interpolate_4(r0, r1, f.x);\nfloat topOfGrid = c_NoiseSimple_f_noise_interpolate_4(r2, r3, f.x);\nfloat t = c_NoiseSimple_f_noise_interpolate_4(bottomOfGrid, topOfGrid, f.y);\nreturn t;\n }\nfloat c_NoiseSimple_main_4(vec2 UV, float Scale) {\n   float t = 0.0;\n   float freq = pow(2.0, 0.0);\n   float amp = pow(0.5, 3.0);\n   t += c_NoiseSimple_f_value_noise_4(vec2(UV.x * Scale / freq, UV.y * Scale / freq)) * amp;\n   freq = pow(2.0, 1.0);\n   amp = pow(0.5, 2.0);\n   t += c_NoiseSimple_f_value_noise_4(vec2(UV.x * Scale / freq, UV.y * Scale / freq)) * amp;\n   freq = pow(2.0, 2.0);\n   amp = pow(0.5, 1.0);\n   t += c_NoiseSimple_f_value_noise_4(vec2(UV.x * Scale / freq, UV.y * Scale / freq)) * amp;\n   return t;\n}\nfloat c_Step1_main_7(float Input, float Edge) {\n    return step(Edge, Input);\n}\nfloat c_Mul1_main_9(float InputA, float InputB) {\n    return (InputA * InputB);\n}\nvec4 c_1To4_main_11(float Input) {\n    return vec4(Input);\n}\nvec4 c_Mul4_main_12(vec4 InputA, vec4 InputB) {\n    return (InputA * InputB);\n}\nfloat c_Complement1_main_13(float Input) {\n    return (1.0 - Input);\n}\nfloat c_Mul1_main_14(float InputA, float InputB) {\n    return (InputA * InputB);\n}\nvec4 c_1To4_main_19(float Input) {\n    return vec4(Input);\n}\nvec4 c_Add4_main_20(vec4 InputA, vec4 InputB) {\n    return (InputA + InputB);\n}\nvec4 c_Output_main_1(vec4 Color) {\n    return Color;\n}\nvoid main()\n{\n    vec2 out_UV_UV0_5 = c_UV0_main_5();\n    vec4 out_Color_TextureToRGBA_3 = c_TextureToRGBA_main_3(out_UV_UV0_5, texture);\n    float out_a_TextureToRGBA_3 = out_Color_TextureToRGBA_3.a;\n    vec2 out_Output_1To2_32 = c_1To2_main_32(Scale);\n    vec2 out_UV_UVTilingAndOffset_30 = c_UVTilingAndOffset_main_30(out_UV_UV0_5, out_Output_1To2_32, v_uv0);\n    float out_Output_NoiseSimple_4 = c_NoiseSimple_main_4(out_UV_UVTilingAndOffset_30, Size);\n    float out_Output_Step1_7 = c_Step1_main_7(out_Output_NoiseSimple_4, Edge);\n    float out_Output_Mul1_9 = c_Mul1_main_9(out_Output_Step1_7, out_a_TextureToRGBA_3);\n    vec4 out_Output_1To4_11 = c_1To4_main_11(out_Output_Mul1_9);\n    vec4 out_Output_Mul4_12 = c_Mul4_main_12(out_Color_TextureToRGBA_3, out_Output_1To4_11);\n    float out_Output_Complement1_13 = c_Complement1_main_13(out_Output_Mul1_9);\n    float out_Output_Mul1_14 = c_Mul1_main_14(out_a_TextureToRGBA_3, out_Output_Complement1_13);\n    vec4 out_Output_1To4_19 = c_1To4_main_19(out_Output_Mul1_14);\n    vec4 out_Output_Add4_20 = c_Add4_main_20(out_Output_Mul4_12, out_Output_1To4_19);\n    gl_FragColor = c_Output_main_1(out_Output_Add4_20);\n}"
      }
    }
  ],
  "subMetas": {}
}