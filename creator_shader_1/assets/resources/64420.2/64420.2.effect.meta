{
  "ver": "1.0.25",
  "uuid": "0a2dde40-5ee8-4f80-a339-0f8a7ddc20e9",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute lowp vec4 a_color;\nattribute mediump vec2 a_uv0;\nvarying mediump vec2 v_uv0;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_wp;\n void main () {\n   mat4 mvp;\n   mvp = cc_matViewProj;\n   v_color = a_color;\n   gl_Position = mvp * vec4(a_position, 1);\n   v_wp = cc_matWorld * vec4(a_position, 1);\n   v_uv0 = a_uv0;\n }",
        "frag": "\nprecision mediump float;\nuniform sampler2D texture;\nuniform sampler2D texture2;\nuniform float u_time;\nvarying mediump vec2 v_uv0;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_wp;\nvec3  iResolution = vec3(0.0);\nvec2 rotate(vec2 v, float c, float s){\n  return vec2(v.x*c - v.y*s, v.x*s + v.y*c);\n}\nvec2 rotate(vec2 v, float r){\n  return rotate(v, cos(r), sin(r));\n}\nfloat boxLength(vec2 pos) {\n  vec2 q = abs(pos);\n  return max(q.x, q.y);\n}\nfloat capsuleLength(vec2 pos, vec2 dir) {\n  vec2 ba = -dir;\n  vec2 pa = pos + ba;\n  ba *= 2.0;\n  return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\nfloat triangleLength(vec2 p) {\n    p.y += 0.32;\n  return max(abs(p.x * 1.8) + p.y, 1.0 - p.y * 1.8) * 0.75;\n}\nfloat Bu(vec2 pos){\n   float a = capsuleLength(pos + vec2(0.0, -0.5), vec2(1.0, 0.0));\n   float b = capsuleLength(pos + vec2(-0.3, 0.3), vec2(1.0, 1.0) * 0.707);\n    float c = length(pos + vec2(-1.3, -1.3));\n    float d = length(pos + vec2(-1.8, -1.3));\n    return min(min(min(a, b), c), d);\n}\nfloat Chi(vec2 pos){\n   float a = capsuleLength(pos + vec2(0.0, -0.0), vec2(1.0, 0.0));\n   float b = capsuleLength(pos + vec2(0.0, -1.3), vec2(1.0, 0.8) * 0.4);\n    float c = capsuleLength(pos + vec2(0.0, -0.0), vec2(0.1, 1.0));\n    return min(min(a, b), c);\n}\nfloat To(vec2 pos){\n   float a = capsuleLength(pos + vec2(0.5, 0.0), vec2(0.0, 1.0));\n   float b = capsuleLength(pos + vec2(0.0, 0.0), vec2(1.0, -0.8) * 0.4);\n    return min(a, b);\n}\nfloat Ba(vec2 pos){\n   float a = capsuleLength(pos + vec2(0.8, 0.0), vec2(0.3, 1.0));\n   float b = capsuleLength(pos + vec2(-0.8, 0.0), vec2(-0.3, 1.0));\n    float c = length(pos + vec2(-1.3, -1.3));\n    float d = length(pos + vec2(-1.8, -1.3));\n    return min(min(min(a, b), c), d);\n}\nfloat Butitoba(vec2 pos, float power){\n    float ret = 0.0\n     + power / Bu(pos)\n     + power / Chi(pos + vec2(-3.0, 0.0))\n     + power / To(pos + vec2(-6.0, 0.0))\n     + power / Ba(pos + vec2(-9.0, 0.0))\n        ;\n    return ret;\n}\nfloat smoothstepLine(float lower, float upper, float value, float width){\n    width *= 0.5;\n    return smoothstep(lower - width, lower, value) * (1.0 - smoothstep(upper, upper + width, value));\n}\nfloat smoothLine(float value, float target, float width){\n    return width / abs(value - target);\n}\nvec2 smoothLine2(float value, float target, float width){\n    return vec2(step(0.0, value - target), width / abs(value - target));\n}\nfloat circleTriangle(vec2 pos){\n    float circle = length(pos * 0.5);\n    float triangle = triangleLength(pos * 0.3);\n    return smoothLine(circle, 1.0, 0.025) + smoothLine(triangle, 1.0, 0.025);\n}\nvec2 circleTriangle2(vec2 pos){\n    float circle2 = length(pos * 0.35);\n    vec2 ret = smoothLine2(circle2, 1.0, 0.025);\n    ret.y += circleTriangle(pos);\n    return ret;\n}\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y) * (3.1415926535897932384626433832795 * 0.5) : atan(y, x);\n}\nvec2 polar(vec2 uv) {\n  float r = length(uv);\n  float s = atan2(uv.y, uv.x) / 3.1415926535897932384626433832795;\n  return vec2(r, s);\n}\nfloat ButitobaCircle(vec2 pos){\n    vec2 pp = polar(rotate(pos, -u_time) * 0.75);\n    return Butitoba(mod(rotate(pp * vec2(2.0, 32.0), (3.1415926535897932384626433832795 * 0.5)), vec2(16.0, 4.0)) - 1.5, 0.05) * smoothstepLine(6.0, 7.5, pp.x, 1.5);\n}\nfloat ButitobaCircle2(vec2 pos, float scale, float x, float y, float x2, float y2, float lower, float upper, float r){\n    vec2 pp = polar(rotate(pos, r) * scale);\n    return Butitoba(mod(rotate(pp * vec2(x, y), (3.1415926535897932384626433832795 * 0.5)), vec2(x2, y2)) - 1.5, 0.03) * smoothstepLine(lower, upper, pp.x, 0.2);\n}\nvoid mainImage(  )\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * 20.0;\n    uv *= clamp(u_time * 0.25, 0.0, 1.0);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    uv = rotate(uv, u_time * 0.3);\n    vec2 c2 = circleTriangle2(uv * 1.4 + vec2(0.0, 8.0));\n    vec2 c3 = circleTriangle2(uv * 1.4 + rotate(vec2(0.0, 8.0), 3.1415926535897932384626433832795 * 2.0 * 0.3333));\n    vec2 c4 = circleTriangle2(uv * 1.4 + rotate(vec2(0.0, 8.0), 3.1415926535897932384626433832795 * 2.0 * 0.6666));\n    float mask = c2.x * c3.x * c4.x;\n    float len = length(uv);\n   col.g = col.b =\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.0 + u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.25 - u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.5 + u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.75 - u_time * 0.5)) - 4.5);\n    col.g += col.b = ButitobaCircle(uv)\n        + (ButitobaCircle2(uv, 0.995, 8.0, 64.0, 12.0, 4.0, 7.5, 8.0, 5.0 + u_time * 0.2)\n        + smoothLine(len, 10.0+0.25*abs(sin(u_time)), 0.02)\n        + smoothLine(len, 7.75+0.25*abs(cos(u_time)), 0.02)\n        + smoothLine(len, 2.75+7.75*abs(mod(u_time*0.8, 1.0)), 0.02)\n        + ButitobaCircle2(uv, 1.1, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 5.0 - u_time * 0.75)\n        + ButitobaCircle2(uv, 1.2, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 15.0 + u_time * 0.275)\n        + ButitobaCircle2(uv, 1.45, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 15.0 + u_time * 0.2418654)\n        + smoothLine(len, 5.0, 0.02)\n        + smoothLine(len, 5.5, 0.02)\n        + ButitobaCircle2(uv, 2.15, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 35.0 + u_time * 0.34685)\n        + ButitobaCircle2(uv, 2.25, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 135.0 + u_time * 0.114)\n        + ButitobaCircle2(uv, 1.8, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 532.0 + u_time * 0.54158)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.0 + u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.25 - u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.5 + u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.75 - u_time * 0.5)) - 4.5)\n        + 0.1 / abs(boxLength(uv * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n        + 0.1 / abs(boxLength(rotate(uv, 3.1415926535897932384626433832795 * 2.0 * 0.3333) * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n        + 0.1 / abs(boxLength(rotate(uv, 3.1415926535897932384626433832795 * 2.0 * 0.6666) * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n          ) * mask\n        + circleTriangle(uv)\n        + c2.y\n      + c3.y\n       + c4.y\n        ;\n    gl_FragColor = vec4(col, 1.0);\n}\nvoid main(void)\n{\n    iResolution = vec3(vec2(960.,640.), 0.0);\n    mainImage();\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nattribute vec3 a_position;\nattribute lowp vec4 a_color;\nattribute mediump vec2 a_uv0;\nvarying mediump vec2 v_uv0;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_wp;\n void main () {\n   mat4 mvp;\n   mvp = cc_matViewProj;\n   v_color = a_color;\n   gl_Position = mvp * vec4(a_position, 1);\n   v_wp = cc_matWorld * vec4(a_position, 1);\n   v_uv0 = a_uv0;\n }",
        "frag": "\nprecision mediump float;\nuniform sampler2D texture;\nuniform sampler2D texture2;\nuniform Constants1 {\n  vec2 u_mouse;\n  float u_time;\n};\nvarying mediump vec2 v_uv0;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_wp;\nvec3  iResolution = vec3(0.0);\nvec2 rotate(vec2 v, float c, float s){\n  return vec2(v.x*c - v.y*s, v.x*s + v.y*c);\n}\nvec2 rotate(vec2 v, float r){\n  return rotate(v, cos(r), sin(r));\n}\nfloat boxLength(vec2 pos) {\n  vec2 q = abs(pos);\n  return max(q.x, q.y);\n}\nfloat capsuleLength(vec2 pos, vec2 dir) {\n  vec2 ba = -dir;\n  vec2 pa = pos + ba;\n  ba *= 2.0;\n  return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\nfloat triangleLength(vec2 p) {\n    p.y += 0.32;\n  return max(abs(p.x * 1.8) + p.y, 1.0 - p.y * 1.8) * 0.75;\n}\nfloat Bu(vec2 pos){\n   float a = capsuleLength(pos + vec2(0.0, -0.5), vec2(1.0, 0.0));\n   float b = capsuleLength(pos + vec2(-0.3, 0.3), vec2(1.0, 1.0) * 0.707);\n    float c = length(pos + vec2(-1.3, -1.3));\n    float d = length(pos + vec2(-1.8, -1.3));\n    return min(min(min(a, b), c), d);\n}\nfloat Chi(vec2 pos){\n   float a = capsuleLength(pos + vec2(0.0, -0.0), vec2(1.0, 0.0));\n   float b = capsuleLength(pos + vec2(0.0, -1.3), vec2(1.0, 0.8) * 0.4);\n    float c = capsuleLength(pos + vec2(0.0, -0.0), vec2(0.1, 1.0));\n    return min(min(a, b), c);\n}\nfloat To(vec2 pos){\n   float a = capsuleLength(pos + vec2(0.5, 0.0), vec2(0.0, 1.0));\n   float b = capsuleLength(pos + vec2(0.0, 0.0), vec2(1.0, -0.8) * 0.4);\n    return min(a, b);\n}\nfloat Ba(vec2 pos){\n   float a = capsuleLength(pos + vec2(0.8, 0.0), vec2(0.3, 1.0));\n   float b = capsuleLength(pos + vec2(-0.8, 0.0), vec2(-0.3, 1.0));\n    float c = length(pos + vec2(-1.3, -1.3));\n    float d = length(pos + vec2(-1.8, -1.3));\n    return min(min(min(a, b), c), d);\n}\nfloat Butitoba(vec2 pos, float power){\n    float ret = 0.0\n     + power / Bu(pos)\n     + power / Chi(pos + vec2(-3.0, 0.0))\n     + power / To(pos + vec2(-6.0, 0.0))\n     + power / Ba(pos + vec2(-9.0, 0.0))\n        ;\n    return ret;\n}\nfloat smoothstepLine(float lower, float upper, float value, float width){\n    width *= 0.5;\n    return smoothstep(lower - width, lower, value) * (1.0 - smoothstep(upper, upper + width, value));\n}\nfloat smoothLine(float value, float target, float width){\n    return width / abs(value - target);\n}\nvec2 smoothLine2(float value, float target, float width){\n    return vec2(step(0.0, value - target), width / abs(value - target));\n}\nfloat circleTriangle(vec2 pos){\n    float circle = length(pos * 0.5);\n    float triangle = triangleLength(pos * 0.3);\n    return smoothLine(circle, 1.0, 0.025) + smoothLine(triangle, 1.0, 0.025);\n}\nvec2 circleTriangle2(vec2 pos){\n    float circle2 = length(pos * 0.35);\n    vec2 ret = smoothLine2(circle2, 1.0, 0.025);\n    ret.y += circleTriangle(pos);\n    return ret;\n}\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y) * (3.1415926535897932384626433832795 * 0.5) : atan(y, x);\n}\nvec2 polar(vec2 uv) {\n  float r = length(uv);\n  float s = atan2(uv.y, uv.x) / 3.1415926535897932384626433832795;\n  return vec2(r, s);\n}\nfloat ButitobaCircle(vec2 pos){\n    vec2 pp = polar(rotate(pos, -u_time) * 0.75);\n    return Butitoba(mod(rotate(pp * vec2(2.0, 32.0), (3.1415926535897932384626433832795 * 0.5)), vec2(16.0, 4.0)) - 1.5, 0.05) * smoothstepLine(6.0, 7.5, pp.x, 1.5);\n}\nfloat ButitobaCircle2(vec2 pos, float scale, float x, float y, float x2, float y2, float lower, float upper, float r){\n    vec2 pp = polar(rotate(pos, r) * scale);\n    return Butitoba(mod(rotate(pp * vec2(x, y), (3.1415926535897932384626433832795 * 0.5)), vec2(x2, y2)) - 1.5, 0.03) * smoothstepLine(lower, upper, pp.x, 0.2);\n}\nvoid mainImage(  )\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * 20.0;\n    uv *= clamp(u_time * 0.25, 0.0, 1.0);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    uv = rotate(uv, u_time * 0.3);\n    vec2 c2 = circleTriangle2(uv * 1.4 + vec2(0.0, 8.0));\n    vec2 c3 = circleTriangle2(uv * 1.4 + rotate(vec2(0.0, 8.0), 3.1415926535897932384626433832795 * 2.0 * 0.3333));\n    vec2 c4 = circleTriangle2(uv * 1.4 + rotate(vec2(0.0, 8.0), 3.1415926535897932384626433832795 * 2.0 * 0.6666));\n    float mask = c2.x * c3.x * c4.x;\n    float len = length(uv);\n   col.g = col.b =\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.0 + u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.25 - u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.5 + u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.75 - u_time * 0.5)) - 4.5);\n    col.g += col.b = ButitobaCircle(uv)\n        + (ButitobaCircle2(uv, 0.995, 8.0, 64.0, 12.0, 4.0, 7.5, 8.0, 5.0 + u_time * 0.2)\n        + smoothLine(len, 10.0+0.25*abs(sin(u_time)), 0.02)\n        + smoothLine(len, 7.75+0.25*abs(cos(u_time)), 0.02)\n        + smoothLine(len, 2.75+7.75*abs(mod(u_time*0.8, 1.0)), 0.02)\n        + ButitobaCircle2(uv, 1.1, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 5.0 - u_time * 0.75)\n        + ButitobaCircle2(uv, 1.2, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 15.0 + u_time * 0.275)\n        + ButitobaCircle2(uv, 1.45, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 15.0 + u_time * 0.2418654)\n        + smoothLine(len, 5.0, 0.02)\n        + smoothLine(len, 5.5, 0.02)\n        + ButitobaCircle2(uv, 2.15, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 35.0 + u_time * 0.34685)\n        + ButitobaCircle2(uv, 2.25, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 135.0 + u_time * 0.114)\n        + ButitobaCircle2(uv, 1.8, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 532.0 + u_time * 0.54158)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.0 + u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.25 - u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.5 + u_time * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, (3.1415926535897932384626433832795 * 0.5) * 0.75 - u_time * 0.5)) - 4.5)\n        + 0.1 / abs(boxLength(uv * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n        + 0.1 / abs(boxLength(rotate(uv, 3.1415926535897932384626433832795 * 2.0 * 0.3333) * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n        + 0.1 / abs(boxLength(rotate(uv, 3.1415926535897932384626433832795 * 2.0 * 0.6666) * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n          ) * mask\n        + circleTriangle(uv)\n        + c2.y\n      + c3.y\n       + c4.y\n        ;\n    gl_FragColor = vec4(col, 1.0);\n}\nvoid main(void)\n{\n    iResolution = vec3(vec2(960.,640.), 0.0);\n    mainImage();\n}"
      }
    }
  ],
  "subMetas": {}
}