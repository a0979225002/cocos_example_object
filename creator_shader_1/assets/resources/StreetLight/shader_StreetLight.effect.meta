{
  "ver": "1.0.25",
  "uuid": "47bd646a-5ef9-42b0-893a-b3d40f03b8c9",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute lowp vec4 a_color;\nattribute mediump vec2 a_uv0;\nvarying mediump vec2 v_uv0;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_wp;\nvoid main () {\n  mat4 mvp;\n  mvp = cc_matViewProj;\n  v_color = a_color;\n  gl_Position = mvp * vec4(a_position, 1);\n  v_wp = cc_matWorld * vec4(a_position, 1);\n    #if USE_TEXTURE\n    v_uv0 = a_uv0;\n    #endif\n}",
        "frag": "\n#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\nuniform sampler2D texture;\nuniform sampler2D texture2;\nuniform vec2 u_mouse;\nuniform float u_time;\nvarying mediump vec2 v_uv0;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_wp;\nconst float tau = 3.14159265 * 2.;\nfloat sqr(float x) { return x*x; }\nfloat saw(float x) { return 2.*abs(fract(x-.5)-.5); }\nvec4 hash42(vec2 p)\n{\n  vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec2 hash21(float p)\n{\n  vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec4 renderSnowLayer(vec2 uv, int layer, float u_time, float dx)\n{\n    vec4 col = vec4(0);\n    float fi = float(layer)*.25;\n    float tileSize = fi;\n    dx *= tileSize;\n    float fallRate = .7 / fi;\n    float windRate = .7 / fi;\n    vec2 tileSpace = (uv + hash21(fi) + vec2(windRate, fallRate)*u_time) * tileSize;\n    vec2 tileId = floor(tileSpace);\n    vec2 tileUV = fract(tileSpace);\n    vec4 rnd = hash42(tileId + fi*vec2(-3.3, 5.7));\n    float flakeT = 2.*u_time*(.25 + .75*rnd.x) + rnd.y*tau;\n    flakeT = sin(flakeT)*tau/4. + tau/2.;\n    vec2 flakePos = .25 + .5*rnd.zw + .15*vec2(sin(flakeT),cos(flakeT));\n    float flakeRad = .1;\n    float d = distance(tileUV, flakePos) - flakeRad;\n    vec2 lightPos = vec2(1.1, 1.1);\n    float falloff = smoothstep(1.3, .0, sqr(distance(uv, lightPos)));\n    float focus = pow(dot(normalize(uv - lightPos), vec2(0,-1)),9.);\n    float light = mix(1., 1., focus * falloff);\n    vec2 txuv = tileUV - flakePos;\n    float txuvr = length(txuv);\n    float txuva = atan(txuv.y, txuv.x);\n    txuva = saw(6.*(txuva/tau+u_time*(rnd.x-.5)))*.5 + rnd.y*tau;\n    float tres = 600.;\n    float tx = smoothstep(0., sqr(txuvr*30.), texture2D(texture, txuv*(50./tres)).x);\n    col += smoothstep(+dx, -dx, d) * vec4(light) * tx;\n    return col;\n}\nvoid main(  )\n{\nvec2 uv = vec2(1. - v_uv0.x,v_uv0.y);vec2 st = uv;;\n uv = vec2(uv.x,1.-uv.y);\n    float dx = 1.*length(fwidth(uv));\n    float u_time = u_time + u_mouse.x/100.;\n    float t = cos(tau*u_time/120.)*.5+.5;\n    for (int i = 1; i < 64; i++) {\n        gl_FragColor += renderSnowLayer(uv, i, u_time, dx);\n    }\n    gl_FragColor.w = 1.;\n    vec2 uv11 = uv;\n    uv11.y = 1. - uv11.y;\n    gl_FragColor.xyz = gl_FragColor.xyz * 0.5 + texture2D(texture2, uv11).xyz;\n    gl_FragColor.xyz += smoothstep(.3, .1, uv.y);\n    gl_FragColor.xyz += step(.7,gl_FragColor.x) * gl_FragColor.x;\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nattribute vec3 a_position;\nattribute lowp vec4 a_color;\nattribute mediump vec2 a_uv0;\nvarying mediump vec2 v_uv0;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_wp;\nvoid main () {\n  mat4 mvp;\n  mvp = cc_matViewProj;\n  v_color = a_color;\n  gl_Position = mvp * vec4(a_position, 1);\n  v_wp = cc_matWorld * vec4(a_position, 1);\n    #if USE_TEXTURE\n    v_uv0 = a_uv0;\n    #endif\n}",
        "frag": "\n#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\nuniform sampler2D texture;\nuniform sampler2D texture2;\nuniform Constants1 {\n  vec4 u_Position;\n  vec2 u_mouse;\n  float u_Radius;\n  float u_time;\n  float u_Vague;\n};\nvarying mediump vec2 v_uv0;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_wp;\nconst float tau = 3.14159265 * 2.;\nfloat sqr(float x) { return x*x; }\nfloat saw(float x) { return 2.*abs(fract(x-.5)-.5); }\nvec4 hash42(vec2 p)\n{\n  vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec2 hash21(float p)\n{\n  vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec4 renderSnowLayer(vec2 uv, int layer, float u_time, float dx)\n{\n    vec4 col = vec4(0);\n    float fi = float(layer)*.25;\n    float tileSize = fi;\n    dx *= tileSize;\n    float fallRate = .7 / fi;\n    float windRate = .7 / fi;\n    vec2 tileSpace = (uv + hash21(fi) + vec2(windRate, fallRate)*u_time) * tileSize;\n    vec2 tileId = floor(tileSpace);\n    vec2 tileUV = fract(tileSpace);\n    vec4 rnd = hash42(tileId + fi*vec2(-3.3, 5.7));\n    float flakeT = 2.*u_time*(.25 + .75*rnd.x) + rnd.y*tau;\n    flakeT = sin(flakeT)*tau/4. + tau/2.;\n    vec2 flakePos = .25 + .5*rnd.zw + .15*vec2(sin(flakeT),cos(flakeT));\n    float flakeRad = .1;\n    float d = distance(tileUV, flakePos) - flakeRad;\n    vec2 lightPos = vec2(1.1, 1.1);\n    float falloff = smoothstep(1.3, .0, sqr(distance(uv, lightPos)));\n    float focus = pow(dot(normalize(uv - lightPos), vec2(0,-1)),9.);\n    float light = mix(1., 1., focus * falloff);\n    vec2 txuv = tileUV - flakePos;\n    float txuvr = length(txuv);\n    float txuva = atan(txuv.y, txuv.x);\n    txuva = saw(6.*(txuva/tau+u_time*(rnd.x-.5)))*.5 + rnd.y*tau;\n    float tres = 600.;\n    float tx = smoothstep(0., sqr(txuvr*30.), texture2D(texture, txuv*(50./tres)).x);\n    col += smoothstep(+dx, -dx, d) * vec4(light) * tx;\n    return col;\n}\nvoid main(  )\n{\nvec2 uv = vec2(1. - v_uv0.x,v_uv0.y);vec2 st = uv;;\n uv = vec2(uv.x,1.-uv.y);\n    float dx = 1.*length(fwidth(uv));\n    float u_time = u_time + u_mouse.x/100.;\n    float t = cos(tau*u_time/120.)*.5+.5;\n    for (int i = 1; i < 64; i++) {\n        gl_FragColor += renderSnowLayer(uv, i, u_time, dx);\n    }\n    gl_FragColor.w = 1.;\n    vec2 uv11 = uv;\n    uv11.y = 1. - uv11.y;\n    gl_FragColor.xyz = gl_FragColor.xyz * 0.5 + texture2D(texture2, uv11).xyz;\n    gl_FragColor.xyz += smoothstep(.3, .1, uv.y);\n    gl_FragColor.xyz += step(.7,gl_FragColor.x) * gl_FragColor.x;\n}"
      }
    }
  ],
  "subMetas": {}
}